{"version":3,"sources":["components/slider.tsx","components/button.tsx","components/titledToolbarContainer.tsx","components/checkBox.tsx","components/dropdown.tsx","components/toolbar.tsx","components/canvas.tsx","graph/vertex.ts","graph/edge.ts","components/grid.tsx","utils/hashMap.ts","utils/hashSet.ts","graph/graph.ts","utils/queue.ts","graph/algorithms.ts","utils/rng.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Slider","props","state","sliderValue","event","this","onSliderChange","parseInt","currentTarget","value","setState","prevState","type","max","sliderLength","onChange","handleOnChange","name","label","React","Component","Button","handleClick","bind","onClick","className","style","backgroundColor","display","justifyContent","padding","TitledToolbarContainer","border","borderRadius","margin","color","textAlign","paddingBottom","title","children","CheckBox","checkBoxRef","createRef","checkBox","current","checked","onSelect","marginBottom","ref","DropDown","options","map","option","htmlFor","id","defaultValue","Toolbar","handleOnStart","graphProps","onSelectDirectedEdges","onSelectShowWeights","onSelectShowVertexPositions","gridSizeSliderProps","onClear","startButtonProps","onSelection","onGenerateGrid","onGenerateRandom","animationSpeedSliderProps","onStart","hover_shade","Canvas","canvasRef","canvas","constCanvasElement","onContextMenu","handleRightClick","onMouseMove","ctx","getContext","width","WIDTH","height","HEIGHT","scale","window","devicePixelRatio","Math","floor","drawGrid","hoveringVertex","hoveringEdge","currentVertex","graph","isDirected","getIsDirected","showPositions","getShowPositions","vertices","edges","edge","drawDirectedEdge","COLORS","directed_edge_color","drawUndirectedEdge","undirected_edge_color","drawDirectedHoverEdge","drawUndirectedHoverEdge","animationFrame","drawFrame","drawHoverVertex","drawVertexPosition","vertex","equals","drawGraphVertex","drawCurrentVertex","getShowWeights","drawEdgeWeight","gridSize","nodeRadius","fillStyle","fillRect","strokeStyle","grid_color","inactive_node_color","i","j","xpos","ypos","beginPath","moveTo","lineTo","stroke","arc","PI","fill","x","y","r","lineWidth","save","restore","v","pos","getPosition","drawCircle","VERTEX_RADIUS","drawVertex","node_hover_color","current_node_color","active_node_color","translate","strPos","font","fillText","measureText","e","start","end","hover_edge_color","drawEdgeArrow","v1","v2","angle","atan2","cos","sin","rotate","clip","round","weight","getWeight","toString","strokeRect","frame","outlineVertices","redVertices","yellowVertices","greenVertices","redEdges","yellowEdges","greenEdges","colors","defaultProps","edge_hover_color","default_edge_color","Vertex","position","data","hash","Edge","p1","p2","parseFloat","sqrt","toFixed","hashCode","Grid","gridState","cursor","nearestVertexInPixels","isAnimating","edgeSet","contains","removeEdge","insertEdge","vertexSet","insertVertex","preventDefault","removeVertex","prevNearestVertexInPixels","nativeEvent","offsetX","offsetY","PixelsToVertex","inVertexRadius","handleMouseMove","point","vertexPoint","val","nearest","nearestPixelNode","nearestVertex","euclideanDist","HashMap","table","size","length","Array","INITIAL_CAPACITY","key","Error","MAX_LOAD_FACTOR","resizeBackingTable","index","hashAndCompression","getKey","getNext","MapEntry","oldValue","getValue","setValue","toRemove","setNext","keys","entry","push","values","oldTable","counter","head","abs","next","obj","HashSet","put","PRESENT","remove","containsKey","keySet","getSize","getSet","Graph","showWeights","adjacencyMap","u","get","outgoing","getStart","getEnd","incoming","add","IncidenceMap","insertEdgeHelper","incidenceMap","reverseEdge","Queue","arr","element","first","shift","isEmpty","breadthFirstSearch","startVertex","animation","AnimationBuilder","visited","queue","enqueue","dequeue","outgoingEdges","opposite","recursiveDepthFirstSearch","dfsHelper","visitedVertices","discoveryEdges","addFrame","frames","cloneFrame","slice","cloneArray","getRandomInt","min","ceil","random","getRandomBoolean","App","gridSizeValues","animationSpeeds","algorithms","onDirected","onShowWeights","onShowPositions","onGridSizeChange","onAnimationSpeedChange","animationSpeed","algorithm","Object","directedEdges","setIsDirected","setShowWeights","setShowPositions","hdivs","vdivs","clear","xstep","ystep","s","d","right","down","intervalDelay","getFrames","setTimeout","Fragment","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.61474a78.chunk.js","sourcesContent":["import React from 'react';\n\ninterface Props {\n    label: string,\n    sliderLength: number\n    sliderValue: number,\n    onSliderChange: (sliderValue: number) => void;\n}\n\ninterface State {\n    sliderValue: number\n}\n\nclass Slider extends React.Component<Props, State> {\n\n    constructor(props: Props) {\n        super(props);\n        this.state = {\n            sliderValue: this.props.sliderValue\n        }\n    }\n\n    handleOnChange(event: React.ChangeEvent<HTMLInputElement>) {\n        this.props.onSliderChange(parseInt(event.currentTarget.value));\n    }\n\n    componentDidUpdate() {\n        this.setState((prevState, props) => {\n            if (props.sliderValue !== prevState.sliderValue) {\n                return {\n                    sliderValue: props.sliderValue\n                }\n            }\n        });\n    }\n\n    render() {\n\n        return (\n            <>\n                <input \n                    type=\"range\" \n                    value={this.state.sliderValue} \n                    max={this.props.sliderLength - 1} \n                    onChange={(event) => this.handleOnChange(event)} \n                    name=\"slider\"\n                />\n                <label>{this.props.label}</label>\n            </>\n        );\n\n    }\n}\n\nexport default Slider;","import React from \"react\";\nimport './styles.css'\n\ninterface Props {\n    label: string,\n    onClick: () => void\n}\n\ninterface State {\n\n}\n\nclass Button extends React.Component<Props, State> {\n\n    constructor(props: Props) {\n        super(props);\n\n        this.handleClick = this.handleClick.bind(this);\n    }   \n\n    handleClick() {     // not necessary?\n        this.props.onClick();\n    }\n\n    render() {\n        let styles = {\n            backgroundColor: '#222222',     // use only one\n            display: 'flex',\n            justifyContent: 'center',\n            padding: '4px',\n        }\n        return (\n            <div className=\"button\" style={styles} onClick={() => this.props.onClick()}>\n                <p className=\"button\" style={{padding: '2px 5px', backgroundColor: '#222222'}}> {this.props.label} </p>\n            </div>\n        );\n    }\n}\n\nexport default Button;","import React from \"react\";\n\ninterface Props {\n    title: string\n}\n\ninterface State {\n\n}\n\nclass TitledToolbarContainer extends React.Component<Props, State> {\n\n    render() {\n        let styles = {\n            // backgroundColor: '#aaaaaa',\n            border: '1px solid black',\n            borderRadius: '8px',\n            padding: '10px',\n            margin: '0 2px',\n            color: 'rgba(255, 255, 255, 0.8)'\n        }\n        return (\n            <div style={styles}>\n                <h3 style={{textAlign: 'center', paddingBottom: 5}}>{this.props.title}</h3>\n                {this.props.children}\n            </div>\n        );\n    }\n}\n\nexport default TitledToolbarContainer;","import React from \"react\";\n\ninterface Props {\n    label: string\n    onSelect: (selected: boolean) => void\n}\n\nclass CheckBox extends React.Component<Props> {\n    private checkBoxRef: React.RefObject<HTMLInputElement>;\n    constructor(props: Props) {\n        super(props);\n\n        this.checkBoxRef = React.createRef();\n        this.handleClick = this.handleClick.bind(this);\n    }\n\n    handleClick() {\n        if (this.checkBoxRef) {\n            let checkBox = this.checkBoxRef.current;\n            if (checkBox?.checked) {\n                this.props.onSelect(true);\n            } else {\n                this.props.onSelect(false);\n            }\n            \n        }\n    }\n\n    render() {\n        let styles = {\n            padding: '2px',\n            marginBottom: '2px'\n        }\n        return (\n            <div style={styles}>\n                <input type='checkbox' onClick={this.handleClick} ref={this.checkBoxRef}></input>\n                <label> {this.props.label}</label>\n            </div>\n        );\n    }\n}\n\nexport default CheckBox;","import React from 'react';\n\ninterface Props {\n    label: string,\n    options: string[];\n    onChange: (option: string) => void\n}\n\ninterface State {\n\n}\n\nclass DropDown extends React.Component<Props, State> {\n    \n    render() {\n        const options = this.props.options.map((option) => <option key={option} value={option}>{option}</option>);\n        return (\n            <div>\n                <label htmlFor=\"dropdown\">{this.props.label} </label>\n                <select \n                    id=\"dropdown\" \n                    defaultValue={this.props.options[0]}\n                    onChange={(event) => this.props.onChange(event.currentTarget.value)}\n                >\n                    {options}\n                </select>\n            </div>\n        );\n    }\n}\n\nexport default DropDown;","import React from 'react';\n\nimport Slider from './slider';\nimport Button from './button';\n\nimport TitledToolbarContainer from './titledToolbarContainer';\nimport CheckBox from './checkBox'\nimport DropDown from './dropdown';\n\ninterface Props {\n    gridSizeSliderProps: {\n        label: string,\n        sliderLength: number,\n        sliderValue: number,\n        onSliderChange: (sliderValue: number) => void\n    },\n    animationSpeedSliderProps: {    // make interface\n        label: string,\n        sliderLength: number,\n        sliderValue: number,\n        onSliderChange: (sliderValue: number) => void\n    }\n    startButtonProps: {\n        options: string[],\n        onStart: () => void,\n        onSelection: (option: string) => void;\n    }\n    graphProps: {\n        onSelectDirectedEdges: (selected: boolean) => void,\n        onSelectShowWeights: (selected: boolean) => void,\n        onSelectShowVertexPositions: (selected: boolean) => void,\n        onGenerateGrid: () => void,\n        onGenerateRandom: () => void,\n        onClear: () => void,\n    }\n}\n\ninterface State {\n    \n}\n\nclass Toolbar extends React.Component<Props, State> {\n\n    constructor(props: Props) {\n        super(props);\n\n        this.handleOnStart = this.handleOnStart.bind(this);\n    }\n\n    handleOnStart() {\n\n    }\n    \n    render() {\n        let styles = {\n            // height: 160, \n            backgroundColor: '#222222',\n            // backgroundColor: '#5995da',\n            padding: '10px 0',\n            display: 'flex',\n            justifyContent: 'center',\n        }\n        return (\n            <div style={styles}>\n                <TitledToolbarContainer title=\"Graph\">\n                    <CheckBox label='Directed Edges' onSelect={this.props.graphProps.onSelectDirectedEdges}/>\n                    <CheckBox label='Show Weights' onSelect={this.props.graphProps.onSelectShowWeights}/>\n                    <CheckBox label='Show Vertex Positions' onSelect={this.props.graphProps.onSelectShowVertexPositions}/>\n                    <Slider {...this.props.gridSizeSliderProps} /> \n                    <Button label=\"Clear\" onClick={this.props.graphProps.onClear} />\n                </TitledToolbarContainer>\n                <TitledToolbarContainer title=\"Algorithms\">\n                    <DropDown \n                        label=\"Select Algorithm\" \n                        options={this.props.startButtonProps.options} \n                        onChange={(event) => this.props.startButtonProps.onSelection(event)}\n                    />\n                    <Button label=\"Generate Grid Graph\" onClick={this.props.graphProps.onGenerateGrid} />\n                    <Button label=\"Generate Random Graph\" onClick={this.props.graphProps.onGenerateRandom} />\n                </TitledToolbarContainer>\n                <TitledToolbarContainer title=\"Animation\">\n                    <Slider {...this.props.animationSpeedSliderProps} /> \n                    <Button label=\"Start\" onClick={this.props.startButtonProps.onStart}/>\n                </TitledToolbarContainer>\n            </div>\n        );\n    }\n}\n\nexport default Toolbar;","import React from 'react';\nimport './styles.css';\n\nimport Graph from '../graph/graph';\nimport Vertex from '../graph/vertex';\nimport Edge from '../graph/edge';\nimport { GraphAnimationFrame } from '../graph/algorithms';\n\nconst grid_shade = 190;\nconst hover_shade = 190;\n\ninterface Props {\n    gridSize: number,\n    nodeRadius: number,\n    hoveringVertex: Vertex<any> | null,\n    hoveringEdge: Edge<any> | null,\n    currentVertex: Vertex<any> | null,\n    graph: Graph<any>,\n    animationFrame: GraphAnimationFrame | null;\n\n    onClick: (event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => void,\n    handleRightClick: (event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => void,\n    onMouseMove: (event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => void\n}\n\nclass Canvas extends React.Component<Props> {\n\n    public static defaultProps = {\n        nodeRadius: 5\n    }\n\n    private canvasRef: React.RefObject<HTMLCanvasElement>;\n    private canvas: HTMLCanvasElement | null;\n    private constCanvasElement: any;\n    \n    public static VERTEX_RADIUS: number = 10;\n    // public static _WIDTH: number = 1280;\n    // public static _HEIGHT: number = 640;\n    public static WIDTH: number = 1600;\n    public static HEIGHT: number = 800;\n\n    private static COLORS = {\n        grid_color: `rgba(${grid_shade}, ${grid_shade}, ${grid_shade})`,\n        node_hover_color: `rgba(${hover_shade}, ${hover_shade}, ${hover_shade}, 0.5)`,\n        // active_node_color: 'rgba(50, 100, 168, 0.7)',\n        active_node_color: 'rgba(255, 255, 255, 0.3)',\n        // current_node_color: 'rgba(98, 217, 131, 0.5)',\n        current_node_color: 'rgba(255, 255, 255, 0.7)',\n        inactive_node_color: `rgba(${hover_shade}, ${hover_shade}, ${hover_shade}, 0.7)`,\n        edge_hover_color: 'rgba(50, 100, 168, 0.5)',\n        hover_edge_color:'rgba(255, 255, 255, 0.3)',\n        directed_edge_color: 'rgba(255, 255, 255, 0.7)',\n        undirected_edge_color: 'rgba(255, 255, 255, 0.6)',\n        default_edge_color: 'rgba(50, 100, 168, 1)',\n    }\n\n    constructor(props: Props) {\n        super(props);\n\n        this.canvasRef = React.createRef<HTMLCanvasElement>();\n        this.canvas = null;\n\n        // Dan Abramov on SO: a constant element tells React to never rerender.\n        this.constCanvasElement = <canvas\n            id=\"canvas\" \n            ref={this.canvasRef} \n            onClick={this.props.onClick}\n            onContextMenu={this.props.handleRightClick}\n            onMouseMove={this.props.onMouseMove}\n        />      \n    }\n\n    // lifecycle methods\n    componentDidMount() {\n\n        this.canvas = this.canvasRef.current;\n        \n        if (this.canvas) {\n            \n            let ctx = this.canvas.getContext('2d');\n\n            if (ctx) {\n                this.canvas.style.width = `${Canvas.WIDTH}px`;\n                this.canvas.style.height = `${Canvas.HEIGHT}px`;\n\n                let scale = window.devicePixelRatio;    \n\n                this.canvas.width = Math.floor(Canvas.WIDTH * scale);\n                this.canvas.height = Math.floor(Canvas.HEIGHT * scale);\n\n                ctx.scale(scale, scale);\n\n                this.drawGrid(ctx);\n\n            }   \n        }\n    }\n\n    componentDidUpdate() {\n            \n        let ctx = this.canvas!.getContext('2d');\n\n        if (ctx) {\n\n            this.drawGrid(ctx);\n\n            const { \n                hoveringVertex, \n                hoveringEdge, \n                currentVertex, \n                graph } = this.props;\n\n            let isDirected = graph.getIsDirected();\n            let showPositions = graph.getShowPositions();\n            let vertices = graph.vertices();\n            let edges = graph.edges();\n\n            // edge set\n            if (isDirected) {\n                for (let edge of edges) {\n                    this.drawDirectedEdge(edge, Canvas.COLORS.directed_edge_color, ctx);\n                }\n            } else {\n                for (let edge of edges) {\n                    this.drawUndirectedEdge(edge, Canvas.COLORS.undirected_edge_color, ctx);\n                }\n            }     \n            \n            // hover edge\n            if (hoveringEdge) {\n                if (isDirected) {\n                    this.drawDirectedHoverEdge(hoveringEdge, ctx);\n                } else {\n                    this.drawUndirectedHoverEdge(hoveringEdge, ctx);\n                }\n            }\n\n            // animation frame\n            if (this.props.animationFrame) {\n                this.drawFrame(this.props.animationFrame, ctx);\n            }\n\n            // hover vertex\n            if (hoveringVertex) {\n                this.drawHoverVertex(hoveringVertex, ctx);\n                if (showPositions) {\n                    this.drawVertexPosition(hoveringVertex, ctx);\n                }\n            }\n\n            // vertex set\n            for (let vertex of vertices) {\n                if (!vertex.equals(currentVertex)) {\n                    this.drawGraphVertex(vertex, ctx);\n                    // if (this.props.graph.getShowPositions()) {\n                    //     this.drawVertexPosition(vertex);\n                    // }\n                }\n                \n            }\n\n            // current active vertex\n            if (currentVertex) {\n                this.drawCurrentVertex(currentVertex, ctx);\n                // if (this.props.graph.getShowPositions()) {\n                //     this.drawVertexPosition(currentVertex);\n                // }\n                // how about an outline?\n            }\n        \n            // weights \n            if (this.props.graph.getShowWeights()) {\n                for (let edge of edges) {\n                    this.drawEdgeWeight(edge, true, ctx);\n                }\n            }\n        }\n    }\n\n    render() {\n        return (\n            <div className=\"canvas-container\">\n                {this.constCanvasElement}\n            </div>\n        );\n    }\n\n    // drawing handlers\n    drawGrid(ctx: CanvasRenderingContext2D): void {\n\n        const { gridSize, nodeRadius } = this.props;\n        \n        // ctx.clearRect(0, 0, Canvas.WIDTH, Canvas.HEIGHT);\n        // ctx.fillStyle = 'rgba(0, 0, 0, 1)';\n        if (ctx) {\n            ctx.fillStyle = '#444444';     // make constant\n            ctx.fillRect(0, 0, Canvas.WIDTH, Canvas.HEIGHT);\n            ctx.strokeStyle = Canvas.COLORS.grid_color;\n            ctx.fillStyle = Canvas.COLORS.inactive_node_color;\n            \n            for (let i = 1; i < Canvas.WIDTH / gridSize; i++) {   \n                for (let j = 1; j < Canvas.HEIGHT / gridSize; j++) {\n                    \n                    let xpos = i * gridSize;\n                    let ypos = j * gridSize;\n                    \n                    ctx.beginPath();\n                    ctx.moveTo(0, ypos);\n                    ctx.lineTo(Canvas.WIDTH, ypos);\n                    ctx.stroke();\n            \n                    ctx.beginPath();\n                    ctx.moveTo(xpos, 0);\n                    ctx.lineTo(xpos, Canvas.HEIGHT);\n                    ctx.stroke();\n        \n                    ctx.beginPath();\n                    ctx.arc(i * gridSize, j * gridSize, nodeRadius, 0, 2 * Math.PI);\n                    ctx.fill();\n                    \n                }\n            }\n        }\n        \n    }\n\n    drawCircle(x: number, y: number, r: number, color: string, fill = true, ctx: CanvasRenderingContext2D, lineWidth?: number): void {\n        \n        ctx.save();\n        ctx.beginPath();\n        ctx.arc(x, y, r, 0, 2 * Math.PI, true);\n        \n        if (fill) {\n            ctx.fillStyle = color;\n            ctx.fill();\n        } else {\n            if (lineWidth) {\n                ctx.lineWidth = lineWidth;\n            }\n            ctx.strokeStyle = color;\n            ctx.stroke();\n        }\n\n        ctx.restore();\n    }\n\n    drawVertex(v: Vertex<any>, color: string, ctx: CanvasRenderingContext2D): void {\n        \n        const pos: [number, number] = v.getPosition();\n        const { gridSize } = this.props;\n        \n        this.drawCircle(\n            pos[0] * gridSize,\n            pos[1] * gridSize,\n            Canvas.VERTEX_RADIUS,\n            color,\n            true,\n            ctx\n        );\n    }\n\n    drawHoverVertex(v: Vertex<any>, ctx: CanvasRenderingContext2D) {\n        this.drawVertex(v, Canvas.COLORS.node_hover_color, ctx);\n    }\n\n    drawCurrentVertex(v: Vertex<any>, ctx: CanvasRenderingContext2D) {\n        this.drawVertex(v, Canvas.COLORS.current_node_color, ctx);\n    }\n\n    drawGraphVertex(v: Vertex<any>, ctx: CanvasRenderingContext2D) {\n        this.drawVertex(v, Canvas.COLORS.active_node_color, ctx);\n    }\n\n    drawVertexPosition(v: Vertex<any>, ctx: CanvasRenderingContext2D) {\n        let pos = v.getPosition();\n        let { gridSize } = this.props;\n        let x = pos[0] * gridSize;\n        let y = pos[1] * gridSize;\n\n        ctx.save();\n\n        ctx.translate(x, y);\n\n        // ctx.strokeStyle = 'black';\n        // ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';\n        // ctx.strokeRect(-30, -30, 20, 20);\n        // ctx.fillRect(-30, -30, 20, 20);\n\n        // text   (todo: extract draw text method)\n        let strPos = `(${pos[0]}, ${pos[1]})`;\n        ctx.font = '18px serif';\n        ctx.fillStyle = 'rgba(255, 255, 0, 0.9)';\n        ctx.fillText(strPos, -(ctx.measureText(strPos).width + 10), -10);\n        ctx.restore();\n\n        ctx.restore();\n    }\n\n    drawUndirectedEdge(e: Edge<any>, color: string, ctx: CanvasRenderingContext2D): void {\n\n        let start = e.start.getPosition();\n        let end = e.end.getPosition();\n        const { gridSize, nodeRadius } = this.props;\n\n        ctx.save();\n        ctx.strokeStyle = color;\n        ctx.lineWidth = nodeRadius;\n        ctx.beginPath();\n        ctx.moveTo(start[0] * gridSize, start[1] * gridSize);\n        ctx.lineTo(end[0] * gridSize, end[1] * gridSize);\n        ctx.stroke();\n        ctx.restore();\n    }\n\n    drawUndirectedHoverEdge(e: Edge<any>, ctx: CanvasRenderingContext2D): void {\n        // let c = 'rgba(255, 255, 255, 0.3)';\n        this.drawUndirectedEdge(e, Canvas.COLORS.hover_edge_color, ctx);\n    }\n\n    drawDirectedEdge(e: Edge<any>, color: string, ctx: CanvasRenderingContext2D): void {\n        this.drawUndirectedEdge(e, color, ctx);\n        this.drawEdgeArrow(e, color, ctx);\n    }\n\n    drawDirectedHoverEdge(e: Edge<any>, ctx: CanvasRenderingContext2D): void {     // rectify alpha channel later.\n        this.drawDirectedEdge(e, Canvas.COLORS.hover_edge_color, ctx);\n    }\n\n    drawEdgeArrow(e: Edge<any>, color: string, ctx: CanvasRenderingContext2D) {\n        let v1 = e.start.getPosition();\n        let v2 = e.end.getPosition();\n\n        let { gridSize } = this.props;\n        let angle = Math.atan2(v2[1] - v1[1], v2[0] - v1[0]);\n        let mag = 10;\n        \n        ctx.save();\n        \n        if (color) {\n            ctx.strokeStyle = ctx.fillStyle = color;\n        } else {\n            ctx.strokeStyle = ctx.fillStyle = Canvas.COLORS.current_node_color;\n        }\n\n        ctx.translate(\n            v2[0] * gridSize - this.props.nodeRadius * Math.cos(angle),\n            v2[1] * gridSize - this.props.nodeRadius * Math.sin(angle)\n        );\n\n        ctx.rotate(angle);\n        \n        ctx.moveTo(-1.4 * mag, 0);\n        ctx.lineTo(-2 * mag, 0.8 * mag);\n        ctx.lineTo(0, 0);\n        ctx.lineTo(-2 * mag, -0.8 * mag);\n        ctx.lineTo(-1.4 * mag, 0);\n        ctx.stroke();\n        ctx.clip();\n        ctx.fill();\n\n        ctx.restore();\n    }\n\n    drawEdgeWeight(e: Edge<any>, round: boolean = false, ctx: CanvasRenderingContext2D) {\n\n        let v1 = e.start.getPosition();\n        let v2 = e.end.getPosition();\n        let weight: string = e.getWeight().toString();\n        ctx.save();\n    \n        ctx.translate(\n            0.5 * (v2[0] + v1[0]) * this.props.gridSize,\n            0.5 * (v2[1] + v1[1]) * this.props.gridSize\n        );\n        \n        // container\n        if (round) {\n            this.drawCircle(0, 0, 15, 'rgba(255, 255, 255, 0.8)', true, ctx);\n            this.drawCircle(0, 0, 15, 'black', false, ctx);\n        } else {\n            ctx.strokeStyle = 'black';\n            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n            ctx.strokeRect(-15, -15, 30, 30);\n            ctx.fillRect(-15, -15, 30, 30);\n        }\n\n        // weight\n        ctx.font = '18px serif';\n        ctx.fillStyle = 'black';\n        ctx.fillText(weight, -ctx.measureText(weight).width / 2, 6);\n        ctx.restore();\n    }\n\n    drawFrame(frame: GraphAnimationFrame, ctx: CanvasRenderingContext2D) {\n        \n        const {\n            outlineVertices, \n            redVertices, \n            yellowVertices, \n            greenVertices, \n            redEdges, \n            yellowEdges, \n            greenEdges } = frame;\n\n        const colors = {\n            outV: 'rgba(57, 99, 237, 0.8)',\n            redV: 'rgba(252, 77, 61, 1.0)',\n            redE: 'rgba(252, 77, 61, 1.0)',\n            yellowV: 'rgba(255, 255, 0, 0.9)',\n            yellowE: 'rgba(255, 255, 0, 0.9)',\n            greenV: 'rgba(57, 237, 171, 0.8)',\n            greenE: 'rgba(57, 237, 171, 0.8)',\n        }\n\n        const { gridSize, graph } = this.props;\n        const isDirected = graph.getIsDirected()\n        \n        if (isDirected) {\n            if (redEdges) {\n                for (let edge of redEdges) {\n                    this.drawDirectedEdge(edge, colors.redE, ctx);\n                }\n            }\n\n            if (yellowEdges) {\n                for (let edge of yellowEdges) {\n                    this.drawDirectedEdge(edge, colors.yellowE, ctx);\n                }\n            }\n\n            if (greenEdges) {\n                for (let edge of greenEdges) {\n                    this.drawDirectedEdge(edge, colors.greenE, ctx);\n                }\n            }\n            \n        } else {\n            if (redEdges) {\n                for (let edge of redEdges) {\n                    this.drawUndirectedEdge(edge, colors.redE, ctx);\n                }\n            }\n\n            if (yellowEdges) {\n                for (let edge of yellowEdges) {\n                    this.drawUndirectedEdge(edge, colors.yellowE, ctx);\n                }\n            }\n\n            if (greenEdges) {\n                for (let edge of greenEdges) {\n                    this.drawUndirectedEdge(edge, colors.greenE, ctx);\n                }\n            }\n        }\n\n        if (redVertices) {\n            for (let vertex of redVertices) {\n                this.drawVertex(vertex, colors.redV, ctx);\n            }\n        }\n\n        if (yellowVertices) {\n            for (let vertex of yellowVertices) {\n                this.drawVertex(vertex, colors.yellowV, ctx);\n            }\n        }\n\n        if (greenVertices) {\n            for (let vertex of greenVertices) {\n                this.drawVertex(vertex, colors.greenV, ctx);\n            }\n        }\n        \n        if (outlineVertices) {\n            for (let vertex of outlineVertices) {\n                let v = vertex.getPosition();\n                this.drawCircle(\n                    v[0] * gridSize, \n                    v[1] * gridSize,\n                    Canvas.VERTEX_RADIUS + 2, \n                    colors.outV,\n                    false,\n                    ctx,\n                    3\n                );\n            }\n        }\n        \n    }\n}\n\nexport default Canvas;\n\n// Notes:\n/* \n\nAbstract canvas array, separate logic and drawing between two components > done\nUse setState to trigger rerenders > done\nPrevent the canvas element itself from rerendering. > done\nUsing offsetX and offsetY breaks when zooming in with trackpad. (Standard browser zooming works)\n\n*/","export default class Vertex<T> {\n\n    private position: [number, number];\n    private data: T | undefined; \n\n    constructor(position: [number, number], data?: T) {\n        this.position = position;\n        this.data = data;\n    }\n\n    equals(v: Object | null): boolean {\n        if (!(v instanceof Vertex) || v == null) {\n            return false;\n        } else if (this.position[0] === v.position[0] && this.position[1] === v.position[1]) {\n            return true;\n        }\n        return false;\n    }\n\n    getPosition(): [number, number] {\n        return this.position;\n    }\n\n    getData(): T | undefined {\n        return this.data;\n    }\n    \n    toString(): string {\n        return `x: ${this.position[0]}, y:${this.position[1]}`;\n    }\n\n    hashCode(): number {\n        let hash = 19;\n        hash = 29 * hash + this.position[0];\n        return 31 * hash + this.position[1];\n    }\n}   ","import Vertex from './vertex';\n\nexport default class Edge<T> {\n\n    public start: Vertex<T>;\n    public end: Vertex<T>;\n    \n    private weight: number;\n\n    constructor(start: Vertex<T>, end: Vertex<T>, weight?: number) {\n        this.start = start;\n        this.end = end;\n        if (weight) {\n            this.weight = weight;\n        } else {\n            let p1 = this.start.getPosition();\n            let p2 = this.end.getPosition();\n            // todo: replace with Euclidean Distance method in Grid Component. Extract as utility method.\n            this.weight = parseFloat((Math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)).toFixed(1));  \n        }\n    }\n\n    equals(e: Object): boolean {\n        if (!(e instanceof Edge) || e == null) {\n            return false;\n        } else if (this.start.equals(e.start) && this.end.equals(e.end)) {\n            return true;\n        }\n        return false;\n    }\n\n    getStart(): Vertex<T> {\n        return this.start;\n    }\n\n    getEnd(): Vertex<T> {\n        return this.end;\n    }\n\n    getWeight(): number {\n        return this.weight;\n    }\n\n    toString(): string {\n        return `start: ${this.start}, end:${this.end}`;\n    }\n\n    hashCode(): number {\n        let hash = 19;\n        hash = 29 * hash + this.start.hashCode();\n        return 31 * hash + this.end.hashCode();\n    }\n}","import React from 'react';\nimport Canvas from './canvas';\n\nimport Vertex from '../graph/vertex';\nimport Edge from '../graph/edge';\nimport Graph from '../graph/graph'\nimport { GraphAnimationFrame } from '../graph/algorithms';\n\ninterface Props {\n    gridSize: number,\n    nodeRadius: number,\n    graph: Graph<any>,\n    isAnimating: boolean,\n    animationFrame: GraphAnimationFrame | null;\n}\n\ninterface State {\n    hoveringVertex: Vertex<any> | null,\n    currentVertex: Vertex<any> | null,\n    hoveringEdge: Edge<any> | null,\n    graph: Graph<any>\n}\n\ninterface GridState {\n    cursor: [number, number],\n    nearestVertexInPixels: [number, number],\n}\n\nclass Grid extends React.Component<Props, State> {\n\n    private gridState: GridState;\n\n    constructor(props: Props) {\n        super(props);\n\n        let graph = this.props.graph\n\n        this.state = {\n            hoveringVertex: null,\n            currentVertex: null,\n            hoveringEdge: null,\n            graph: graph,\n        }\n\n        this.gridState = {\n            cursor: [-1, -1],\n            nearestVertexInPixels: [-1, -1],\n        }\n    }\n\n    handleClick(event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) {\n\n        if (this.props.isAnimating) {\n            return;\n        }\n\n        if (this.state.hoveringVertex) {\n            if (this.state.hoveringVertex.equals(this.state.currentVertex)) {\n                this.setState({\n                    currentVertex: null,\n                    hoveringEdge: null\n                });\n            } else {\n                if (this.state.hoveringEdge) {\n                    if (!this.state.graph.edgeSet.contains(this.state.hoveringEdge)) {\n                        this.state.graph.insertEdge(this.state.hoveringEdge);\n                    } else {\n                        this.state.graph.removeEdge(this.state.hoveringEdge);\n                    }\n                }\n\n                this.setState({\n                    currentVertex: this.state.hoveringVertex,\n                    hoveringEdge: null\n                });\n            }\n\n            if (!this.state.graph.vertexSet.contains(this.state.hoveringVertex)) {\n                this.state.graph.insertVertex(this.state.hoveringVertex);\n            }\n        }\n    }\n\n    handleRightClick(event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) {\n        \n        event.preventDefault();\n\n        if (this.props.isAnimating) {\n            return;\n        }\n\n        if (this.state.hoveringVertex) {\n            if (this.state.graph.vertexSet.contains(this.state.hoveringVertex)) {\n                this.state.graph.removeVertex(this.state.hoveringVertex);\n                this.setState({\n                    currentVertex: null,\n                    hoveringEdge: null\n                });\n            }\n        }\n    }\n\n    handleMouseMove(event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) {\n\n        if (this.props.isAnimating) {\n            return;\n        }\n\n        let prevNearestVertexInPixels = this.gridState.nearestVertexInPixels;   // keek track of Vertex object instead of tuple.\n        this.gridState.cursor = [event.nativeEvent.offsetX, event.nativeEvent.offsetY];\n\n        if (this.nearestVertexInPixels(this.gridState.cursor)[0] !== prevNearestVertexInPixels[0] || \n            this.nearestVertexInPixels(this.gridState.cursor)[1] !== prevNearestVertexInPixels[1]) {\n                this.gridState.nearestVertexInPixels = this.nearestVertexInPixels(this.gridState.cursor);\n\n                if (this.state.currentVertex) {\n                    let hoveringEdge = new Edge(this.state.currentVertex, this.PixelsToVertex(this.gridState.nearestVertexInPixels), 0);\n                    this.setState({\n                        hoveringEdge: hoveringEdge\n                    });\n                }\n            }\n        \n        if (this.inVertexRadius(this.gridState.cursor)) {\n    \n            if (!this.state.hoveringVertex) {\n                this.setState({\n                    hoveringVertex: this.PixelsToVertex(this.gridState.nearestVertexInPixels)\n                });\n            }\n\n        } else {\n            \n            if (this.state.hoveringVertex) {\n                this.setState({\n                    hoveringVertex: null\n                });\n            }\n        }\n\n    }\n\n    render() {\n        return (<Canvas \n          gridSize={this.props.gridSize}\n          nodeRadius={this.props.nodeRadius}\n          hoveringVertex={this.state.hoveringVertex}\n          hoveringEdge={this.state.hoveringEdge}\n          currentVertex={this.state.currentVertex}\n          graph={this.state.graph}\n          animationFrame={this.props.animationFrame}\n\n          onClick={(event) => this.handleClick(event)}\n          handleRightClick={(event) => this.handleRightClick(event)}\n          onMouseMove={(event) => this.handleMouseMove(event)}\n        />);\n    }\n\n    // utility methods\n\n    PixelsToVertex(point: [number, number]): Vertex<any> {\n        let vertexPoint = point.map((val) => val / this.props.gridSize);\n        return new Vertex([vertexPoint[0], vertexPoint[1]]);\n    }\n\n    /**\n     * \n     * @param cursor size 2 array where cursor[0] = cursorX, cursor[1] = cursorY; pixel position on canvas element.\n     * @returns pixel position of nearest vertex relative to cursor position on grid as size 2 array.\n     */\n     nearestVertexInPixels(cursor: [number, number]): [number, number] {\n        \n        const { gridSize } = this.props;\n        let nearest: number[] = cursor.map((val) => Math.round(val / gridSize) * gridSize)\n        let nearestPixelNode: [number, number] = [nearest[0], nearest[1]];\n        \n        switch (nearestPixelNode[0]) {\n            case 0:\n                nearestPixelNode[0] += gridSize;\n                break;\n            case Canvas.WIDTH:\n                nearestPixelNode[0] -= gridSize;\n                break;\n            default:\n                break;\n        }\n\n        switch (nearestPixelNode[1]) {\n            case 0:\n                nearestPixelNode[1] += gridSize;\n                break;\n            case Canvas.HEIGHT:\n                nearestPixelNode[1] -= gridSize;\n                break;\n            default:\n                break;\n        }\n\n        return nearestPixelNode;\n    }\n\n    inVertexRadius(cursor: [number, number]): boolean {\n        let nearestVertex: [number, number] = this.nearestVertexInPixels(cursor);\n        if (nearestVertex[0] > 0 && nearestVertex[0] < Canvas.WIDTH && nearestVertex[1] > 0 && nearestVertex[1] < Canvas.HEIGHT) {\n            return this.euclideanDist(cursor, nearestVertex) < Canvas.VERTEX_RADIUS;\n        }\n        return false;\n    }\n\n    euclideanDist(p1: number[], p2: number[]) {\n        return Math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2);\n    }\n\n}\n\nexport default Grid;","import { Hashable } from \"./hashable\";\n\n// TODO: See deductions and rectify!\n\nexport default class HashMap<K extends Hashable, V> {\n\n    private table: (MapEntry<K, V> | null)[];\n    private size: number;\n    private length: number;\n\n    public static readonly INITIAL_CAPACITY = 13;\n    public static readonly MAX_LOAD_FACTOR = 0.75;\n\n    constructor() {\n        this.table = new Array<MapEntry<K, V> | null>(HashMap.INITIAL_CAPACITY);\n        this.length = HashMap.INITIAL_CAPACITY;\n        this.size = 0;\n    }\n\n    public put(key: K, value: V): V | null {\n        // exceptions\n        if (key == null) {\n            throw new Error(\"Key is null.\");\n        } else if (value == null) {\n            throw new Error(\"Value is null.\");\n        }\n\n        // load factor check\n        if ((this.size + 1) / (this.length) > HashMap.MAX_LOAD_FACTOR) {\n            this.resizeBackingTable(2 * this.length + 1);\n        }\n\n        // index corresponding to key in the table\n        let index: number = this.hashAndCompression(key);\n        let current: MapEntry<K, V> | null = this.table[index];\n\n        // duplicate check\n        while (current != null && !current.getKey().equals(key)) {\n            current = current.getNext();\n        }\n\n        // current == null <-> unique entry\n        if (current == null) {\n            this.table[index] = new MapEntry<K, V>(key, value, this.table[index]);\n            this.size++;\n            return null;\n        }\n        // current != null <-> duplicate entry\n        let oldValue: V = current.getValue();\n        current.setValue(value);\n        return oldValue;\n    }\n\n    public remove(key: K): V {\n        if (key == null) {\n            throw new Error(\"Given key is null.\");\n        }\n        let index = this.hashAndCompression(key);\n        let current: MapEntry<K, V> | null = this.table[index];\n\n        if (current == null) {\n            throw new Error(`Key: ${key} not in map.`);\n        }\n\n        let toRemove: V | null = null;\n        \n        if (current.getKey().equals(key)) {\n            toRemove = current.getValue();\n            this.table[index] = current.getNext();\n            this.size--;\n            return toRemove;\n        }\n\n        while (current != null && current.getNext() != null) {\n            if (current.getNext()!.getKey().equals(key)) {\n                toRemove = current.getNext()!.getValue();\n                current.setNext(current.getNext()!.getNext());\n                this.size--;\n                break;\n            }\n            current = current.getNext();\n        }\n\n        if (toRemove == null) {\n            throw new Error(`Key: ${key} not in map.`);\n        }\n\n        return toRemove;\n    }\n\n    public get(key: K): V {\n        if (key == null) {\n            throw new Error(\"Key is null.\");\n        }\n        let index = this.hashAndCompression(key);\n        let current = this.table[index];\n\n        while (current != null) {\n            if (current.getKey().equals(key)) {\n                return current.getValue();\n            }\n            current = current.getNext();\n        }\n        throw new Error(\"Key: \" + key + \" not in map.\");\n    }\n\n    public containsKey(key: K): boolean {\n        if (key == null) {\n            throw new Error(\"Key is null.\");\n        }\n        let index = this.hashAndCompression(key);\n        let current = this.table[index];\n        while (current != null) {\n            if (current.getKey().equals(key)) {\n                return true;\n            }\n            current = current.getNext();\n        }\n        return false;\n    }\n\n    public keySet(): K[] {\n    // public keySet(): HashSet<K> {\n        \n        // let keys = new HashSet<K>();\n        let keys: K[] = [];\n        for (let entry of this.table) {\n            if (entry) {\n                let current: MapEntry<K, V> | null = entry;\n                while (current != null) {\n                    keys.push(current.getKey());\n                    current = current.getNext();\n                }\n            }\n\n            // break on keys.size() == size\n            // if (keys.getSize() === this.size) {\n            if (keys.length === this.size) {\n                break;      // prevents traversal of additional null values in table base array.\n            }\n        }\n\n        return keys;\n    }\n\n    public values(): V[] {\n        let values = [];\n        for (let entry of this.table) {\n            if (entry) {\n                let current: MapEntry<K, V> | null = entry;\n                while (current != null) {\n                    values.push(current.getValue());\n                    current = current.getNext();\n                }\n            }\n            if (values.length === this.size) {\n                break;      // prevents traversal of additional null values in table base array.\n            }\n        }\n\n        return values;\n    }\n\n    public getSize() {\n        return this.size;\n    }\n\n    public clear(): void {\n        this.table = new Array<MapEntry<K, V> | null>(HashMap.INITIAL_CAPACITY);\n        this.length = HashMap.INITIAL_CAPACITY;\n        this.size = 0;\n    }\n\n    private resizeBackingTable(length: number): void {\n        \n        if (length < this.size) {\n            throw new Error(`Length: ${length} is less than current size of hash map.`);\n        }\n\n        // if length == table.length, new table will remain unchanged after 'resize'.\n        if (length === this.length) {\n            return;\n        }\n\n        // initialize new array.\n        let oldTable: (MapEntry<K, V> | null)[] = this.table;\n        this.table = new Array<MapEntry<K, V>>(length);\n        this.length = length;\n        let counter = 0;\n\n        // hash and compress elements iteratively and add to new array.\n        for (let head of oldTable) {\n            if (head) {\n                let current: MapEntry<K, V> | null = head;\n                \n                while (current) {\n                    let key: K = current.getKey();\n                    let value: V = current.getValue();\n                    let index = this.hashAndCompression(key);\n                    this.table[index] = new MapEntry<K, V>(key, value, this.table[index]);\n                    counter++;\n                    current = current.getNext();\n                }\n            }\n\n            if (counter === this.size) {\n                return;\n            }\n        }\n    }\n\n    private hashAndCompression(key: K): number {\n        return Math.abs(key.hashCode() % this.length);\n    }\n}\n\n\nclass MapEntry<K extends Hashable, V> {\n\n    private key: K;\n    private value: V;\n    private next: MapEntry<K, V> | null;\n\n    /**\n     * Constructs a new MapEntry with the given key, value, and next reference.\n     *\n     * @param key   the key in the new entry\n     * @param value the value in the new entry\n     * @param next  the next entry in the external chain\n     */\n    constructor(key: K, value: V, next: MapEntry<K, V> | null) {\n        this.key = key;\n        this.value = value;\n        if (next) {\n            this.next = next;\n        } else {\n            this.next = null;\n        }\n    }\n\n    public getKey(): K {\n        return this.key;\n    }\n\n    public getValue(): V {\n        return this.value;\n    }\n\n    public getNext(): MapEntry<K, V> | null {\n        return this.next;\n    }\n\n    public setKey(key: K): void {\n        this.key = key;\n    }\n\n    public setValue(value: V): void {\n        this.value = value;\n    }\n\n    public setNext(next: MapEntry<K, V> | null): void {\n        this.next = next;\n    }\n\n    public toString(): string {\n        let key: string = this.key.toString();\n        let value: V = this.value;\n        return `(${key}, ${value})`;\n    }\n\n    public equals(obj: object): boolean {\n        if (!(obj instanceof MapEntry)) {\n            return false;\n        } else {\n            // let other: MapEntry<K, V> = obj as MapEntry<K, V>;\n            return obj.getKey().equals(this.key) && obj.getValue().equals(this.value);\n        }\n    }\n}","import { Hashable } from './hashable'\nimport HashMap from './hashMap';\n\n/**\n * HashSet based on the Java Implementation of the same\n */\nexport default class HashSet<E extends Hashable> {\n    private static readonly PRESENT: Object = {};\n    private map: HashMap<E, Object>;\n    \n    constructor() {\n        this.map = new HashMap();\n    }\n\n    public add(data: E): void {\n        this.map.put(data, HashSet.PRESENT);\n    }\n\n    public remove(data: E) {\n      return this.map.remove(data);\n    }\n\n    public contains(data: E): boolean {\n        return this.map.containsKey(data);\n    }\n\n    public getSet(): E[] {\n        return this.map.keySet();\n    }\n\n    getSize(): number {\n        return this.map.getSize();\n    }\n\n    clear(): void {\n        this.map = new HashMap();\n    }\n\n    toString(): string {\n        return this.getSet().toString();\n    }\n}","import Vertex from \"./vertex\";\nimport Edge from \"./edge\";\nimport HashSet from \"../utils/hashSet\";\nimport HashMap from \"../utils/hashMap\";\nimport { Equatable } from \"../utils/hashable\";\n\n/**\n * Adjacency Map (modified) Implementation of Goodrich, Tamassia, Goldwasser's Graph ADT. (Data Structures and Algorithms in Java)\n */ \nexport default class Graph<T> {\n    \n    private isDirected: boolean;\n    private showWeights: boolean;   // canvas rendering \n    private showPositions: boolean; // canvas rendering \n    public vertexSet: HashSet<Vertex<T>>;   // make private. Use this.references in canvas.\n    public edgeSet: HashSet<Edge<T>>;\n    private adjacencyMap: HashMap<Vertex<T>, IncidenceMapInterface<T>>;     // ?use linked positional list for vertices \n\n    constructor(isDirected: boolean, showWeights: boolean, showPositions: boolean) {\n        this.isDirected = isDirected;\n        this.showWeights = showWeights;\n        this.showPositions = showPositions;\n\n        this.vertexSet = new HashSet();\n        this.edgeSet = new HashSet();\n        this.adjacencyMap = new HashMap();\n    }\n\n    numVertices(): number  {\n        return this.vertexSet.getSize();\n    }\n\n    numEdges(): number {\n        return this.edgeSet.getSize();\n    }\n\n    vertices(): Vertex<T>[] {\n        return this.vertexSet.getSet();\n    }\n\n    edges(): Edge<T>[] {\n        return this.edgeSet.getSet();\n    }\n\n    getEdge(u: Vertex<T>, v: Vertex<T>): Edge<T> | null {\n        try {\n            return this.adjacencyMap.get(u).outgoing.get(v);\n        } catch {\n            return null;\n        }\n    }\n\n    endVertices(e: Edge<T>): Vertex<T>[] {\n        return [e.getStart(), e.getEnd()];\n    }\n\n    opposite(v: Vertex<T>, e: Edge<T>) {\n        if (v.equals(e.getStart())) {\n            return e.getEnd();\n        } else if (v.equals(e.getEnd())) {\n            return e.getStart();\n        } else {\n            throw new Error(`${e} not incident to ${v}`);\n        }\n    }\n\n    outDegree(v: Vertex<T>): number {\n        return this.adjacencyMap.get(v).outgoing.getSize();\n    }\n\n    inDegree(v: Vertex<T>): number {\n        return this.adjacencyMap.get(v).incoming.getSize();\n    }\n\n    outgoingEdges(v: Vertex<T>): Edge<T>[] {\n        return this.adjacencyMap.get(v).outgoing.values();\n    }\n\n    incomingEdges(v: Vertex<T>): Edge<T>[] {\n        return this.adjacencyMap.get(v).incoming.values();\n    }\n\n    insertVertex(v: Vertex<T>): void {\n        if (this.vertexSet.contains(v)) {\n            return;\n        }\n\n        this.vertexSet.add(v);\n        this.adjacencyMap.put(v, new IncidenceMap<T>());\n    }\n\n    insertEdge(e: Edge<T>): void {\n        this.insertEdgeHelper(e);\n\n        if (!this.isDirected) {\n            this.insertEdgeHelper(new Edge(e.getEnd(), e.getStart()));\n        }\n    }\n\n    private insertEdgeHelper(e: Edge<T>): void {\n        if (this.edgeSet.contains(e)) {\n            return;\n        }\n\n        this.edgeSet.add(e);\n\n        let u = e.getStart();\n        let v = e.getEnd();\n\n        this.insertVertex(u);\n        this.insertVertex(v);\n\n        this.adjacencyMap.get(u).outgoing.put(v, e);\n        this.adjacencyMap.get(v).incoming.put(u, e);\n    }\n\n    /**\n     * Removes Vertex v and all its incident edges in (deg(v)) time.\n     * @param v \n     */\n    removeVertex(v: Vertex<T>): void {  // return removed Vertex?\n        this.vertexSet.remove(v);\n\n        let incidenceMap = this.adjacencyMap.get(v);\n        \n        for (let edge of incidenceMap.incoming.values()) {\n            this.removeEdge(edge);\n        }\n        \n        for (let edge of incidenceMap.outgoing.values()) {\n            this.removeEdge(edge);\n        }\n\n        this.adjacencyMap.remove(v);\n\n    }\n\n    /**\n     * Removes edge e from the graph in O(1) time.\n     * @param e \n     */\n    removeEdge(e: Edge<T>): void {\n        this.edgeSet.remove(e);\n\n        let u = e.getStart();\n        let v = e.getEnd();\n\n        // remove from u.outgoing\n        this.adjacencyMap.get(u).outgoing.remove(v);\n        // remove from v.incoming\n        this.adjacencyMap.get(v).incoming.remove(u);\n\n        if (!this.isDirected) {     // commenting block out fixed the issue of removing reverse edges. Inspect this.\n            // remove from u.incoming\n            this.adjacencyMap.get(u).incoming.remove(v);\n            // remove from v.outgoing\n            this.adjacencyMap.get(v).outgoing.remove(u);\n            // remove from edgeSet\n            let reverseEdge = new Edge(e.getEnd(), e.getStart());\n            this.edgeSet.remove(reverseEdge);\n        }\n    }\n\n    clear(): void {\n        this.vertexSet = new HashSet();\n        this.edgeSet = new HashSet();\n        this.adjacencyMap = new HashMap();\n    }\n\n    getAdjacencyMap(): HashMap<Vertex<T>, IncidenceMap<T>> {     // for debugging.\n        return this.adjacencyMap;\n    }\n\n    getIsDirected(): boolean {\n        return this.isDirected;\n    }\n\n    setIsDirected(isDirected: boolean): void {\n        \n        if (this.isDirected) {\n            // add reverse edges.\n            for (let edge of this.edgeSet.getSet()) {\n                let reverseEdge = new Edge(edge.getEnd(), edge.getStart());\n                this.insertEdge(reverseEdge);\n            }\n        }\n\n        this.isDirected = isDirected;\n    }\n\n    getShowWeights(): boolean {\n        return this.showWeights;\n    }\n\n    setShowWeights(showWeights: boolean): void {\n        this.showWeights = showWeights;\n    }\n\n    getShowPositions(): boolean {\n        return this.showPositions;\n    }\n\n    setShowPositions(showPositions: boolean): void {\n        this.showPositions = showPositions;\n    }\n\n}\n\ninterface IncidenceMapInterface<T> {\n    incoming: HashMap<Vertex<T>, Edge<T>>,\n    outgoing: HashMap<Vertex<T>, Edge<T>>, \n    equals: (obj: object) => boolean\n}\n\nclass IncidenceMap<T> implements IncidenceMapInterface<T>, Equatable {\n    public incoming: HashMap<Vertex<T>, Edge<T>>\n    public outgoing: HashMap<Vertex<T>, Edge<T>>\n    \n    constructor() {\n        this.incoming = new HashMap();\n        this.outgoing = new HashMap();\n    }\n\n    equals(obj: Object): boolean {\n        if (!(obj instanceof IncidenceMap) || obj == null) {\n            return false;\n        }\n        return this.incoming === obj.incoming && this.outgoing === obj.outgoing;    // reference equality.\n    }\n} \n\n","export default class Queue<T> {\n    private arr: T[];\n    \n    constructor() {\n        this.arr = [];\n    }\n\n    enqueue(element: T): void {\t\n        this.arr.push(element);\n    }\n\n    dequeue(): T {    \n        let first = this.arr.shift();\n        if (first) {\n            return first;\n        } else {\n            throw new Error(\"Underflow.\");\n        }\n    }\n\n    peekFirst(): T | null {\n        if(this.isEmpty()) {\n            return null;\n        }\n        return this.arr[0];\n    }\n\n    isEmpty(): boolean {\n        return this.arr.length === 0;\n    }\n\n}","import HashSet from \"../utils/hashSet\";\nimport Stack from \"../utils/stack\";\nimport Queue from \"../utils/queue\";\nimport Graph from \"./graph\";\nimport Vertex from \"./vertex\";\nimport Edge from \"./edge\";\nimport HashMap from \"../utils/hashMap\";\n\n/*\nOne frame of DFS:\n    actual graph: taken care of by Canvas ComponentDidUpdate\n\n    start vertex: default is first inserted vertex, (todo:) can be changed through toolbar\n    current vertex: the one dfs is called recursively on\n    outgoing edges from current vertex: adjMap\n    visited vertices: maintain a collection\n    discovery edges: maintain a collection\n\n*/\nexport function iterativeDepthFirstSearch(graph: Graph<any>, startVertex: Vertex<any>): AnimationBuilder {\n    let visited = new HashSet<Vertex<any>>();\n    let discovery = new HashMap<Vertex<any>, Edge<any>>();\n    let animation = new AnimationBuilder();\n    let stack = new Stack<Vertex<any>>();\n\n    stack.push(startVertex);\n\n    while (!stack.isEmpty()) {\n        let u = stack.pop();\n\n        // animation.addFrame({ outlineVertices: [u], redVertices: visited.getSet(), redEdges: discovery.values() })\n        visited.add(u);\n        // animation.addFrame({ outlineVertices: [u], redVertices: visited.getSet(), redEdges: discovery.values() })\n\n        for (let edge of graph.outgoingEdges(u)) {\n            let v: Vertex<any> = graph.opposite(u, edge);\n            if (!visited.contains(v)) {\n                discovery.put(v, edge);\n                stack.push(v);\n            }\n        }\n    }\n    \n    return animation;\n}\n\nexport function breadthFirstSearch(graph: Graph<any>, startVertex: Vertex<any>): AnimationBuilder {\n\n    let animation = new AnimationBuilder();\n    let visited = new HashSet<Vertex<any>>();\n    let queue = new Queue<Vertex<any>>();\n    \n    queue.enqueue(startVertex);\n    \n    while (!queue.isEmpty()) {\n        let currentVertex = queue.dequeue();\n        if (!visited.contains(currentVertex)) {\n            visited.add(currentVertex);\n            for (let edge of graph.outgoingEdges(currentVertex)) {\n                let opposite = graph.opposite(currentVertex, edge);\n                queue.enqueue(opposite);\n            }\n        }\n    }\n\n    return animation;\n}\n\nexport function recursiveDepthFirstSearch(graph: Graph<any>, startVertex: Vertex<any>): AnimationBuilder {\n    let animation = new AnimationBuilder();\n    let visited = new HashSet<Vertex<any>>();\n    let discovery = new HashMap<Vertex<any>, Edge<any>>();\n    dfsHelper(graph, startVertex, visited, discovery, animation);\n    return animation;\n}\n\nfunction dfsHelper(graph: Graph<any>, u: Vertex<any>, \n    visitedVertices: HashSet<Vertex<any>>, discoveryEdges: HashMap<Vertex<any>, Edge<any>>, animation: AnimationBuilder) {\n    \n    visitedVertices.add(u);\n    animation.addFrame({ \n        outlineVertices: [u], \n        redVertices: visitedVertices.getSet(), \n        redEdges: discoveryEdges.values(),\n    })\n\n    for (let edge of graph.outgoingEdges(u)) {\n        let v: Vertex<any> = graph.opposite(u, edge);\n        if (!visitedVertices.contains(v)) {\n            discoveryEdges.put(v, edge);\n            animation.addFrame({ \n                outlineVertices: [u], \n                redVertices: visitedVertices.getSet(), \n                redEdges: discoveryEdges.values(), \n                yellowEdges: graph.outgoingEdges(u) \n            });\n\n            dfsHelper(graph, v, visitedVertices, discoveryEdges, animation);\n            animation.addFrame({ \n                outlineVertices: [u], \n                redVertices: visitedVertices.getSet(), \n                redEdges: discoveryEdges.values(), \n            })\n\n        }\n    }\n}\n\nexport class AnimationBuilder {\n    private frames: GraphAnimationFrame[];\n\n    constructor() {\n        this.frames = [];\n    }\n\n    public addFrame(frame: GraphAnimationFrame) {\n        this.frames.push(this.cloneFrame(frame));\n    }\n\n    public getFrames(): GraphAnimationFrame[] {\n        return this.frames;\n    }\n\n    private cloneArray(arr: any[] | null | undefined): any[] | null {\n        return arr ? arr.slice(0, arr.length): null;\n    }\n\n    private cloneFrame(frame: GraphAnimationFrame): GraphAnimationFrame {\n        // todo: explore ways to 'object map'\n        return {\n            outlineVertices: this.cloneArray(frame.outlineVertices),\n            redVertices: this.cloneArray(frame.redVertices),\n            redEdges: this.cloneArray(frame.redEdges),\n            yellowVertices: this.cloneArray(frame.yellowVertices),\n            yellowEdges: this.cloneArray(frame.yellowEdges),\n            greenVertices: this.cloneArray(frame.greenEdges),\n            greenEdges: this.cloneArray(frame.greenEdges)\n        }\n    }\n}\n\nexport interface GraphAnimationFrame {\n    outlineVertices?: Vertex<any>[] | null,\n    redVertices?: Vertex<any>[] | null,\n    redEdges?: Edge<any>[] | null,\n    yellowVertices?: Vertex<any>[] | null,\n    yellowEdges?: Edge<any>[] | null,\n    greenVertices?: Vertex<any>[] | null,\n    greenEdges?: Edge<any>[] | null\n}\n\n// function dfsHelper(graph: Graph<any>, startVertex: Vertex<any>, \n//     visited: HashSet<Vertex<any>>, discovery: HashSet<Edge<any>>, animation: AnimationBuilder): void {\n\n//     // TODO: record discovery edges.\n\n//     // mark start as visited;\n//     // animation.addFrame(visited.getSet(), startVertex, discovery.getSet());\n//     visited.add(startVertex);\n//     animation.addFrame(visited.getSet(), startVertex, discovery.getSet(), null);\n//     // for each of start's outgoing edges:\n//     for (let edge of graph.outgoingEdges(startVertex)) {\n//         // if (other endpoint is not visited):\n//         let opposite = graph.opposite(startVertex, edge);\n//         if (!visited.contains(opposite)) {\n//             // depthFirstSearch(other endpoint of edge);\n//             discovery.add(edge);\n//             animation.addFrame(visited.getSet(), startVertex, discovery.getSet(), graph.outgoingEdges(startVertex));\n//             // display outgoing edges.\n//             // set explorationEdge(edge)\n//             // animation.addFrame(visited.getSet(), discoveryEdges.getSet(), graph.outgoingEdges(startVertex));\n//             dfsHelper(graph, opposite, visited, discovery, animation);\n//             animation.addFrame(visited.getSet(), startVertex, discovery.getSet(), null);\n//         }\n//     }  \n// }\n","/**\n * MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/\n * Global_Objects/Math/random#getting_a_random_integer_between_two_values_inclusive\n * @param min \n * @param max \n * @returns \n */\nexport function getRandomInt(min: number, max: number): number {\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\nexport function getRandomBoolean(): boolean {\n    return getRandomInt(0, 1) === 1;\n}\n\n\n/**\n * RNG with skew.\n * https://stackoverflow.com/a/49434653\n * @param min\n * @param max \n * @param skew \n * @returns \n */\nexport function randn_bm(min: number, max: number, skew: number): number {\n    let u = 0, v = 0;\n    while(u === 0) u = Math.random() //Converting [0,1) to (0,1)\n    while(v === 0) v = Math.random()\n    let num = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v )\n    \n    num = num / 10.0 + 0.5 // Translate to 0 -> 1\n    if (num > 1 || num < 0) \n      num = randn_bm(min, max, skew) // resample between 0 and 1 if out of range\n    \n    else{\n      num = Math.pow(num, skew) // Skew\n      num *= max - min // Stretch to fill range\n      num += min // offset to min\n    }\n    return num\n  }\n\nexport function getSkewedRandomBoolean() {\n    let skews = [0.10, 0.20, 0.80, 1.4, 3, 5, 7, 10, 11];\n    return Math.floor(randn_bm(-1, 2, skews[getRandomInt(0, skews.length - 1)]));\n}\n\nexport function getRandomBool() {\n    return Math.floor(Math.pow(1 - getRandomInt(0, 1), 10)) === 1;\n}\n","import React from 'react';\nimport './App.css';\n\nimport Toolbar from './components/toolbar';\nimport Grid from './components/grid';\nimport Graph from './graph/graph';\nimport { recursiveDepthFirstSearch, breadthFirstSearch, AnimationBuilder, GraphAnimationFrame } from './graph/algorithms';\nimport Vertex from './graph/vertex';\nimport Edge from './graph/edge';\nimport { getRandomBoolean, getRandomInt } from './utils/rng';\n\ninterface Props {\n\n}\n\ninterface State {\n    gridSize: number,\n    animationSpeed: number\n    graph: Graph<any>,\n    isAnimating: boolean,\n    animationFrame: GraphAnimationFrame | null,\n    algorithm: string\n}\n\ninterface IDAlgorithmMap {\n    [key: string]: (graph: Graph<any>, startVertex: Vertex<any>) => AnimationBuilder\n}\n\nclass App extends React.Component<Props, State> {\n\n  // private gridSizeValues: number[] = [100, 80, 40, 32, 25, 20, 16];\n    private gridSizeValues: number[] = [100, 80, 40];\n    private animationSpeeds: number[] = [2000, 1000, 500, 400, 200, 100, 50, 20];\n    private algorithms: IDAlgorithmMap;\n\n    constructor(props: Props) {\n        super(props);\n\n        this.onDirected = this.onDirected.bind(this);\n        this.onShowWeights = this.onShowWeights.bind(this);\n        this.onShowPositions = this.onShowPositions.bind(this);\n        this.onGridSizeChange = this.onGridSizeChange.bind(this);\n        this.onGenerateGrid = this.onGenerateGrid.bind(this);\n        this.onGenerateRandom = this.onGenerateRandom.bind(this);\n        this.onClear = this.onClear.bind(this);\n        this.onSelection = this.onSelection.bind(this);\n        this.onAnimationSpeedChange = this.onAnimationSpeedChange.bind(this);\n        this.onStart = this.onStart.bind(this);\n\n        this.algorithms = {\n            'dfs': recursiveDepthFirstSearch,\n            'bfs': breadthFirstSearch\n        }\n\n        this.state = {\n            gridSize: 0,\n            animationSpeed: 2,\n            graph: new Graph(false, false, false),\n            isAnimating: false,\n            animationFrame: null,\n            algorithm: Object.keys(this.algorithms)[0]\n        }    \n    }\n\n    onDirected(directedEdges: boolean) {\n        this.state.graph.setIsDirected(directedEdges);\n        this.setState({});\n    }\n\n    onShowWeights(showWeights: boolean) {\n        this.state.graph.setShowWeights(showWeights);\n        this.setState({});\n    }\n\n    onShowPositions(showPositions: boolean) {\n        this.state.graph.setShowPositions(showPositions);\n        this.setState({});\n    }\n\n    onGridSizeChange(sliderValue: number) {\n        this.setState({gridSize: sliderValue});\n    }\n\n    onGenerateRandom() {\n        let gridSize = this.gridSizeValues[this.state.gridSize];    // todo: state holds gridSize rather than index\n        let hdivs: number = 1600 / gridSize;\n        let vdivs: number = 800 / gridSize;\n\n        this.state.graph.clear();\n\n        let xstep = [1, 2, 3, 4][getRandomInt(0, 3)];\n        let ystep = [1, 2, 3, 4][getRandomInt(0, 3)];\n\n        for (let y = 1; y < vdivs; y += ystep) {\n            for (let x = 1; x < hdivs; x += xstep) {\n                if (getRandomBoolean() && getRandomBoolean()) {\n                    this.state.graph.insertVertex(new Vertex([x, y]));\n                }\n                \n            }\n        }\n\n        for (let u of this.state.graph.vertices()) {\n            for (let v of this.state.graph.vertices()) {\n                if (getRandomBoolean() && getRandomBoolean() && getRandomBoolean() && !u.equals(v)) {\n                    this.state.graph.insertEdge(new Edge(u, v));\n                }\n            }\n        }\n\n        this.setState({});\n\n    }\n\n    onGenerateGrid() {\n        let gridSize = this.gridSizeValues[this.state.gridSize];\n        let hdivs: number = 1600 / gridSize;\n        let vdivs: number = 800 / gridSize;\n\n        this.state.graph.clear();\n\n        for (let y = 1; y < vdivs; y++) {\n            for (let x = 1; x < hdivs; x++) {\n                // this.state.graph.insertVertex(new Vertex([x, y]));\n                let s = new Vertex([x, y]);\n                let r = new Vertex([x + 1, y]);\n                let d = new Vertex([x, y + 1]);\n                let right = new Edge(s, r);\n                let down = new Edge(s, d);\n                if (x !== hdivs - 1) {\n                    this.state.graph.insertEdge(right);\n                }\n\n                if (y !== vdivs - 1)  {\n                    this.state.graph.insertEdge(down);\n                }\n            }\n        }\n\n        this.setState({});\n    }\n\n    onClear() {\n        this.state.graph.clear();\n        this.setState({});\n    }\n\n    onSelection(option: string) {\n        this.setState({ algorithm: option })\n    }\n\n    onAnimationSpeedChange(sliderValue: number) {\n        this.setState({ animationSpeed: sliderValue });\n    }\n\n    onStart() {\n\n        let intervalDelay = this.animationSpeeds[this.state.animationSpeed];\n\n        if (this.state.graph.vertices().length === 0) {\n            return;\n        }\n\n        this.setState({isAnimating: true});\n\n        let frames = this.algorithms[this.state.algorithm](this.state.graph, this.state.graph.vertices()[0]).getFrames();\n\n        for (let i = 0; i < frames.length; i++) {\n            setTimeout(() => {\n                this.setState({\n                    animationFrame: frames[i]\n                });\n            }, (i + 1) * intervalDelay);\n        }\n\n        // use requestAnimationFrame or recursive setTimout.\n        setTimeout(() => {this.setState({isAnimating: false, animationFrame: null})}, ((frames.length + 1) * intervalDelay) + 3000);\n    }\n\n    render() {\n        return (\n            <React.Fragment>\n                <Toolbar \n                    gridSizeSliderProps={{\n                        label: 'Grid Size',\n                        sliderLength: this.gridSizeValues.length,\n                        sliderValue: this.state.gridSize, \n                        onSliderChange: this.onGridSizeChange\n                    }}\n                    animationSpeedSliderProps={{\n                        label: 'Animation Speed',\n                        sliderLength: this.animationSpeeds.length,\n                        sliderValue: this.state.animationSpeed, \n                        onSliderChange: this.onAnimationSpeedChange\n                    }}\n                    startButtonProps={{\n                        options: Object.keys(this.algorithms),\n                        onStart: this.onStart,\n                        onSelection: this.onSelection\n                    }}\n                    graphProps={{\n                        onSelectDirectedEdges: this.onDirected,\n                        onSelectShowWeights: this.onShowWeights,\n                        onSelectShowVertexPositions: this.onShowPositions,\n                        onGenerateGrid: this.onGenerateGrid,\n                        onGenerateRandom: this.onGenerateRandom,\n                        onClear: this.onClear,\n                    }}\n                />\n                <Grid \n                    gridSize={this.gridSizeValues[this.state.gridSize]} \n                    nodeRadius={5 - this.state.gridSize}\n                    graph={this.state.graph}\n                    isAnimating={this.state.isAnimating}\n                    animationFrame={this.state.animationFrame}\n                />\n            </React.Fragment>\n        );\n    }\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();"],"sourceRoot":""}