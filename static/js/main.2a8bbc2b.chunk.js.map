{"version":3,"sources":["components/slider.tsx","components/button.tsx","components/titledToolbarContainer.tsx","components/checkBox.tsx","components/dropdown.tsx","components/toolbar.tsx","utils/colors.tsx","components/canvas.tsx","graph/vertex.ts","graph/edge.ts","utils/mathFunctions.ts","components/grid.tsx","utils/hashMap.ts","utils/hashSet.ts","graph/graph.ts","utils/queue.ts","graph/algorithms.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Slider","props","state","sliderValue","event","this","onSliderChange","parseInt","currentTarget","value","setState","prevState","type","max","sliderLength","onChange","handleOnChange","name","label","React","Component","Button","handleClick","bind","onClick","className","style","backgroundColor","display","justifyContent","padding","TitledToolbarContainer","border","borderRadius","margin","color","textAlign","paddingBottom","title","children","CheckBox","checkBoxRef","createRef","checkBox","current","checked","onSelect","marginBottom","ref","DropDown","options","map","option","htmlFor","id","defaultValue","Toolbar","handleOnStart","graphProps","onSelectDirectedEdges","onSelectShowWeights","onSelectShowVertexPositions","gridSizeSliderProps","onClear","startButtonProps","onSelection","onGenerateGrid","onGenerateRandom","animationSpeedSliderProps","onStart","rgba","colors","background","gridLines","hoverVertex","hoverEdge","currentVertex","graphVertex","graphEdge","vertexPosition","edgeWeight","edgeWeightBackground","edgeWeightBorder","animRed","animBlue","animGreen","animYellow","Canvas","canvasRef","canvas","constCanvasElement","onContextMenu","handleRightClick","onMouseMove","ctx","getContext","width","WIDTH","height","HEIGHT","scale","window","devicePixelRatio","Math","floor","drawGrid","hoveringVertex","hoveringEdge","graph","animationFrame","isDirected","getIsDirected","showPositions","getShowPositions","vertices","edges","colorFrame","edge","drawDirectedEdge","drawUndirectedEdge","drawHoverVertex","drawVertexPosition","vertex","equals","drawGraphVertex","old","getColor","setColor","drawCurrentVertex","getShowWeights","drawEdgeWeight","unColorFrame","gridSize","nodeRadius","clearRect","fillStyle","strokeStyle","i","j","xpos","ypos","beginPath","moveTo","lineTo","stroke","arc","PI","fill","x","y","r","lineWidth","save","restore","v","pos","getPosition","drawCircle","VERTEX_RADIUS","drawVertex","translate","strPos","font","fillText","measureText","e","start","end","drawEdgeArrow","v1","v2","angle","atan2","cos","sin","rotate","clip","round","weight","getWeight","toString","strokeRect","fillRect","getEdge","getEnd","getStart","frame","redVertices","yellowVertices","greenVertices","redEdges","yellowEdges","greenEdges","colorEdges","colorVertices","defaultProps","Vertex","position","data","hash","Edge","p1","p2","parseFloat","sqrt","toFixed","hashCode","getRandomInt","min","ceil","random","getRandomBoolean","Grid","gridState","cursor","nearestVertexInPixels","isAnimating","edgeSet","contains","removeEdge","insertEdge","newVertex","vertexSet","insertVertex","preventDefault","removeVertex","prevNearestVertexInPixels","nativeEvent","offsetX","offsetY","PixelsToVertex","inVertexRadius","handleMouseMove","point","vertexPoint","val","nearest","nearestPixelNode","nearestVertex","HashMap","table","size","length","Array","INITIAL_CAPACITY","key","Error","MAX_LOAD_FACTOR","resizeBackingTable","index","hashAndCompression","getKey","getNext","MapEntry","oldValue","getValue","setValue","toRemove","setNext","keys","entry","push","values","oldTable","counter","head","abs","next","obj","HashSet","put","PRESENT","remove","containsKey","keySet","getSize","getSet","Graph","showWeights","adjacencyMap","u","get","outgoing","incoming","add","IncidenceMap","insertEdgeHelper","a","b","setStart","setEnd","incidenceMap","reverseEdge","Queue","arr","element","first","shift","isEmpty","breadthFirstSearch","startVertex","animation","AnimationBuilder","visited","discovery","queue","enqueue","dequeue","addFrame","outlineVertices","outgoingEdges","opposite","recursiveDepthFirstSearch","dfsHelper","visitedVertices","discoveryEdges","frames","cloneFrame","slice","cloneArray","App","gridSizeValues","animationSpeeds","algorithms","onDirected","onShowWeights","onShowPositions","onGridSizeChange","onAnimationSpeedChange","onTest","animationSpeed","algorithm","Object","directedEdges","setIsDirected","setShowWeights","setShowPositions","hdivs","vdivs","clear","xstep","ystep","s","d","right","down","intervalDelay","getFrames","setTimeout","console","log","getAdjacencyMap","o","iMap","includes","Fragment","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.2a8bbc2b.chunk.js","sourcesContent":["import React from 'react';\n\ninterface Props {\n    label: string,\n    sliderLength: number\n    sliderValue: number,\n    onSliderChange: (sliderValue: number) => void;\n}\n\ninterface State {\n    sliderValue: number\n}\n\nclass Slider extends React.Component<Props, State> {\n\n    constructor(props: Props) {\n        super(props);\n        this.state = {\n            sliderValue: this.props.sliderValue\n        }\n    }\n\n    handleOnChange(event: React.ChangeEvent<HTMLInputElement>) {\n        this.props.onSliderChange(parseInt(event.currentTarget.value));\n    }\n\n    componentDidUpdate() {\n        this.setState((prevState, props) => {\n            if (props.sliderValue !== prevState.sliderValue) {\n                return {\n                    sliderValue: props.sliderValue\n                }\n            }\n        });\n    }\n\n    render() {\n\n        return (\n            <>\n                <input \n                    type=\"range\" \n                    value={this.state.sliderValue} \n                    max={this.props.sliderLength - 1} \n                    onChange={(event) => this.handleOnChange(event)} \n                    name=\"slider\"\n                />\n                <label>{this.props.label}</label>\n            </>\n        );\n\n    }\n}\n\nexport default Slider;","import React from \"react\";\nimport './styles.css'\n\ninterface Props {\n    label: string,\n    onClick: () => void\n}\n\ninterface State {\n\n}\n\nclass Button extends React.Component<Props, State> {\n\n    constructor(props: Props) {\n        super(props);\n\n        this.handleClick = this.handleClick.bind(this);\n    }   \n\n    handleClick() {     // not necessary?\n        this.props.onClick();\n    }\n\n    render() {\n        let styles = {\n            backgroundColor: '#222222',     // use only one\n            display: 'flex',\n            justifyContent: 'center',\n            padding: '4px',\n        }\n        return (\n            <div className=\"button\" style={styles} onClick={() => this.props.onClick()}>\n                <p className=\"button\" style={{padding: '2px 5px', backgroundColor: '#222222'}}> {this.props.label} </p>\n            </div>\n        );\n    }\n}\n\nexport default Button;","import React from \"react\";\n\ninterface Props {\n    title: string\n}\n\ninterface State {\n\n}\n\nclass TitledToolbarContainer extends React.Component<Props, State> {\n\n    render() {\n        let styles = {\n            backgroundColor: '#333333',\n            border: '1px solid black',\n            borderRadius: '8px',\n            padding: '10px',\n            margin: '0 2px',\n            color: 'rgba(255, 255, 255, 0.8)'\n        }\n        return (\n            <div style={styles}>\n                <h3 style={{textAlign: 'center', paddingBottom: 5}}>{this.props.title}</h3>\n                {this.props.children}\n            </div>\n        );\n    }\n}\n\nexport default TitledToolbarContainer;","import React from \"react\";\n\ninterface Props {\n    label: string\n    onSelect: (selected: boolean) => void\n}\n\nclass CheckBox extends React.Component<Props> {\n    private checkBoxRef: React.RefObject<HTMLInputElement>;\n    constructor(props: Props) {\n        super(props);\n\n        this.checkBoxRef = React.createRef();\n        this.handleClick = this.handleClick.bind(this);\n    }\n\n    handleClick() {\n        if (this.checkBoxRef) {\n            let checkBox = this.checkBoxRef.current;\n            if (checkBox?.checked) {\n                this.props.onSelect(true);\n            } else {\n                this.props.onSelect(false);\n            }\n            \n        }\n    }\n\n    render() {\n        let styles = {\n            padding: '2px',\n            marginBottom: '2px'\n        }\n        return (\n            <div style={styles}>\n                <input type='checkbox' onClick={this.handleClick} ref={this.checkBoxRef}></input>\n                <label> {this.props.label}</label>\n            </div>\n        );\n    }\n}\n\nexport default CheckBox;","import React from 'react';\n\ninterface Props {\n    label: string,\n    options: string[];\n    onChange: (option: string) => void\n}\n\ninterface State {\n\n}\n\nclass DropDown extends React.Component<Props, State> {\n    \n    render() {\n        const options = this.props.options.map((option) => <option key={option} value={option}>{option}</option>);\n        return (\n            <div>\n                <label htmlFor=\"dropdown\">{this.props.label} </label>\n                <select \n                    id=\"dropdown\" \n                    defaultValue={this.props.options[0]}\n                    onChange={(event) => this.props.onChange(event.currentTarget.value)}\n                >\n                    {options}\n                </select>\n            </div>\n        );\n    }\n}\n\nexport default DropDown;","import React from 'react';\n\nimport Slider from './slider';\nimport Button from './button';\nimport './styles.css';\n\nimport TitledToolbarContainer from './titledToolbarContainer';\nimport CheckBox from './checkBox'\nimport DropDown from './dropdown';\n\ninterface Props {\n    gridSizeSliderProps: {\n        label: string,\n        sliderLength: number,\n        sliderValue: number,\n        onSliderChange: (sliderValue: number) => void\n    },\n    animationSpeedSliderProps: {    // make interface\n        label: string,\n        sliderLength: number,\n        sliderValue: number,\n        onSliderChange: (sliderValue: number) => void\n    }\n    startButtonProps: {\n        options: string[],\n        onStart: () => void,\n        onSelection: (option: string) => void,\n    }\n    graphProps: {\n        onSelectDirectedEdges: (selected: boolean) => void,\n        onSelectShowWeights: (selected: boolean) => void,\n        onSelectShowVertexPositions: (selected: boolean) => void,\n        onGenerateGrid: () => void,\n        onGenerateRandom: () => void,\n        onClear: () => void,\n    }\n}\n\ninterface State {\n    \n}\n\nclass Toolbar extends React.Component<Props, State> {\n\n    constructor(props: Props) {\n        super(props);\n\n        this.handleOnStart = this.handleOnStart.bind(this);\n    }\n\n    handleOnStart() {\n\n    }\n    \n    render() {\n        let styles = {\n            backgroundColor: '#222222',\n            // backgroundColor: '#5995da',\n            padding: '10px 0',\n            display: 'flex',\n            justifyContent: 'center',\n        }\n        return (\n            <div style={styles}>\n                <TitledToolbarContainer title=\"Graph\">\n                    <CheckBox label='Directed Edges' onSelect={this.props.graphProps.onSelectDirectedEdges}/>\n                    <CheckBox label='Show Weights' onSelect={this.props.graphProps.onSelectShowWeights}/>\n                    <CheckBox label='Show Vertex Positions' onSelect={this.props.graphProps.onSelectShowVertexPositions}/>\n                    <Slider {...this.props.gridSizeSliderProps} /> \n                    <Button label=\"Clear\" onClick={this.props.graphProps.onClear} />\n                </TitledToolbarContainer>\n                <TitledToolbarContainer title=\"Algorithms\">\n                    <DropDown \n                        label=\"Select Algorithm\" \n                        options={this.props.startButtonProps.options} \n                        onChange={(event) => this.props.startButtonProps.onSelection(event)}\n                    />\n                    <Button label=\"Generate Grid Graph\" onClick={this.props.graphProps.onGenerateGrid} />\n                    <Button label=\"Generate Random Graph\" onClick={this.props.graphProps.onGenerateRandom} />\n                </TitledToolbarContainer>\n                <TitledToolbarContainer title=\"Animation\">\n                    <Slider {...this.props.animationSpeedSliderProps} /> \n                    <Button label=\"Start\" onClick={this.props.startButtonProps.onStart}/>\n                </TitledToolbarContainer>\n                <TitledToolbarContainer title=\"Custom graphs\">\n                    <div>\n                        <p className=\"subtitle\">Addition</p>\n                            1. Click on nodes to start drawing. Click on the currently active source node to exit draw mode. <br />\n                            2. Click on nodes other than the currently active source node to draw edges. <br />\n                            3. Use the toolbar to switch between directed/undirected/weighted/unweighted edges. <br />\n                        <p className=\"subtitle\">Removal</p>\n                            1. Right click on vertex to remove it (and its incident edges, if any). <br />\n                            2. To remove an undirected edge, draw over/retrace the edge. <br />\n                            3. To remove a directed edge, draw/retrace the edge from its tail to the arrowhead. <br />\n                    </div>\n                </TitledToolbarContainer>\n            </div>\n        );\n    }\n}\n\nexport default Toolbar;","export const rgba = {\n    black: 'rgba(0, 0, 0, 1)',\n    partialBlack: 'rgba(0, 0, 0, 0.8)',\n    transBlack: 'rgba(0, 0, 0, 1)',\n    white: 'rgba(255, 255, 255, 1)',\n    partialWhite: 'rgba(255, 255, 255, 0.8)',\n    partialWhite2: 'rgba(255, 255, 255, 0.8)',\n    red: 'rgba(252, 77, 61, 1.0)',\n    blue1: 'rgba(50, 100, 168, 1)',\n    blue2: 'rgba(50, 100, 168, 0.6)',\n    blue3: 'rgba(50, 100, 168, 0.8)',\n    green1: 'rgba(98, 217, 131, 1)',\n    green2: 'rgba(98, 217, 131, 0.5)',\n    yellow: 'rgba(255, 255, 0, 0.9)',\n    orange: 'rgba()',\n    purple: 'rgba()',\n    grey: 'rgba(190, 190, 190, 1)',\n    tsprt_grey: 'rgba(190, 190, 190, 0.8)'\n}\n\nexport const colors = {\n    background: rgba.white,\n    gridLines: rgba.grey,\n    hoverVertex: rgba.tsprt_grey,\n    hoverEdge: rgba.tsprt_grey,\n    currentVertex: rgba.partialWhite,\n    graphVertex: rgba.partialWhite,\n    graphEdge: rgba.partialWhite,\n    vertexPosition: rgba.yellow,\n    edgeWeight: rgba.black,\n    edgeWeightBackground: rgba.partialWhite,\n    edgeWeightBorder: rgba.black,\n    animRed: rgba.red,\n    animBlue: rgba.blue1,\n    animGreen: rgba.green1,\n    animYellow: rgba.yellow,\n}\n\n// const grid_shade = 190;\n// const hover_shade = 190;\n\n// const COLORS = {\n//     grid_color: `rgba(${grid_shade}, ${grid_shade}, ${grid_shade})`,\n//     node_hover_color: `rgba(${hover_shade}, ${hover_shade}, ${hover_shade}, 0.5)`,\n//     // active_node_color: 'rgba(50, 100, 168, 0.7)',\n//     active_node_color: 'rgba(255, 255, 255, 0.3)',\n//     // current_node_color: 'rgba(98, 217, 131, 0.5)',\n//     current_node_color: 'rgba(255, 255, 255, 0.7)',\n//     inactive_node_color: `rgba(${hover_shade}, ${hover_shade}, ${hover_shade}, 0.7)`,\n//     edge_hover_color: 'rgba(50, 100, 168, 0.5)',\n//     hover_edge_color:'rgba(255, 255, 255, 0.3)',\n//     directed_edge_color: 'rgba(255, 255, 255, 0.7)',\n//     undirected_edge_color: 'rgba(255, 255, 255, 0.6)',\n//     default_edge_color: 'rgba(50, 100, 168, 1)',\n// }\n\n// from drawFrame\n\n// const colors = {\n//     outV: 'rgba(57, 99, 237, 0.8)',\n//     redV: 'rgba(252, 77, 61, 1.0)',\n//     redE: 'rgba(252, 77, 61, 1.0)',\n//     yellowV: 'rgba(255, 255, 0, 0.9)',\n//     yellowE: 'rgba(255, 255, 0, 0.9)',\n//     greenV: 'rgba(57, 237, 171, 0.8)',\n//     greenE: 'rgba(57, 237, 171, 0.8)',\n// }","import React from 'react';\nimport './styles.css';\n\nimport Graph from '../graph/graph';\nimport Vertex from '../graph/vertex';\nimport Edge from '../graph/edge';\nimport { GraphAnimationFrame } from '../graph/algorithms';\nimport { colors } from '../utils/colors';\n\ninterface Props {\n    gridSize: number,\n    nodeRadius: number,\n    hoveringVertex: Vertex<any> | null,\n    hoveringEdge: Edge<any> | null,\n    currentVertex: Vertex<any> | null,\n    graph: Graph<any>,\n    animationFrame: GraphAnimationFrame | null;\n\n    onClick: (event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => void,\n    handleRightClick: (event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => void,\n    onMouseMove: (event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => void\n}\n\nclass Canvas extends React.Component<Props> {\n\n    public static defaultProps = {\n        nodeRadius: 5\n    }\n\n    private canvasRef: React.RefObject<HTMLCanvasElement>;\n    private canvas: HTMLCanvasElement | null;\n    private constCanvasElement: any;\n    \n    public static readonly VERTEX_RADIUS: number = 10;\n    // public static _WIDTH: number = 1280;\n    // public static _HEIGHT: number = 640;\n    public static readonly WIDTH: number = 1600;\n    public static readonly HEIGHT: number = 800;\n\n    constructor(props: Props) {\n        super(props);\n\n        this.canvasRef = React.createRef<HTMLCanvasElement>();\n        this.canvas = null;\n\n        // Dan Abramov on SO: a constant element tells React to never rerender.\n        this.constCanvasElement = <canvas\n            id=\"canvas\" \n            ref={this.canvasRef} \n            onClick={this.props.onClick}\n            onContextMenu={this.props.handleRightClick}\n            onMouseMove={this.props.onMouseMove}\n        />      \n    }\n\n    // lifecycle methods\n    componentDidMount() {\n\n        this.canvas = this.canvasRef.current;\n        \n        if (this.canvas) {\n            \n            let ctx = this.canvas.getContext('2d');\n\n            if (ctx) {\n                this.canvas.style.width = `${Canvas.WIDTH}px`;\n                this.canvas.style.height = `${Canvas.HEIGHT}px`;\n\n                let scale = window.devicePixelRatio;    \n\n                this.canvas.width = Math.floor(Canvas.WIDTH * scale);\n                this.canvas.height = Math.floor(Canvas.HEIGHT * scale);\n\n                ctx.scale(scale, scale);\n\n                this.drawGrid(ctx);\n\n            }   \n        }\n    }\n\n    componentDidUpdate() {\n            \n        let ctx = this.canvas!.getContext('2d');\n\n        if (ctx) {\n\n            this.drawGrid(ctx);\n\n            const {\n                // gridSize, \n                hoveringVertex, \n                hoveringEdge, \n                currentVertex, \n                graph,\n                animationFrame } = this.props;\n\n            let isDirected = graph.getIsDirected();\n            let showPositions = graph.getShowPositions();\n            let vertices = graph.vertices();\n            let edges = graph.edges();\n\n            // // color animation frame\n            // if (this.props.animationFrame) {\n            //     this.color(this.props.animationFrame);\n            //     let { outlineVertices } = this.props.animationFrame;\n            //     if (outlineVertices) {\n            //         for (let vertex of outlineVertices) {\n            //             let v = vertex.getPosition();\n            //             this.drawCircle(\n            //                 v[0] * gridSize, \n            //                 v[1] * gridSize,\n            //                 Canvas.VERTEX_RADIUS + 2, \n            //                 colors.animBlue,\n            //                 false,\n            //                 ctx,\n            //                 3\n            //             );\n            //         }\n            //     }\n            // }\n\n            if (animationFrame) {\n                this.colorFrame(animationFrame);\n            }\n\n            // edge set\n            if (isDirected) {\n                for (let edge of edges) {\n                    this.drawDirectedEdge(edge, ctx);\n                }\n            } else {\n                for (let edge of edges) {\n                    this.drawUndirectedEdge(edge, ctx);\n                }\n            }     \n            \n            // hover edge\n            if (hoveringEdge) {\n                if (isDirected) {\n                    // this.drawDirectedHoverEdge(hoveringEdge, ctx);\n                    this.drawDirectedEdge(hoveringEdge, ctx);\n                } else {\n                    // this.drawUndirectedHoverEdge(hoveringEdge, ctx);\n                    this.drawUndirectedEdge(hoveringEdge, ctx);\n                }\n            }\n\n            // hover vertex\n            if (hoveringVertex) {\n                this.drawHoverVertex(hoveringVertex, ctx);\n                if (showPositions) {\n                    this.drawVertexPosition(hoveringVertex, ctx);\n                }\n            }\n\n            // vertex set\n            for (let vertex of vertices) {\n                if (!vertex.equals(currentVertex)) {\n                    this.drawGraphVertex(vertex, ctx);\n                    // if (this.props.graph.getShowPositions()) {\n                    //     this.drawVertexPosition(vertex);\n                    // }\n                }\n            }\n\n            // current active vertex\n            if (currentVertex) {\n                let old = currentVertex.getColor();\n                currentVertex.setColor(colors.currentVertex);\n                this.drawCurrentVertex(currentVertex, ctx);\n                currentVertex.setColor(old);\n                // if (this.props.graph.getShowPositions()) {\n                //     this.drawVertexPosition(currentVertex);\n                // }\n                // how about an outline?\n            }\n        \n            // weights \n            if (this.props.graph.getShowWeights()) {\n                for (let edge of edges) {\n                    this.drawEdgeWeight(edge, false, ctx);\n                }\n            }\n\n            if (animationFrame) {\n                this.unColorFrame(animationFrame);\n            }\n\n            // // deColor animation frame\n            // if (this.props.animationFrame) {\n            //     this.deColor(this.props.animationFrame);\n            // }\n        }\n    }\n\n    render() {\n        return (\n            // todo: fix height to accommodate for different displays\n            <div className=\"canvas-container\" style={{height: Canvas.HEIGHT + 50, backgroundColor: \"#444444\"}}>\n                {this.constCanvasElement}\n            </div>\n        );\n    }\n\n    // drawing handlers\n    drawGrid(ctx: CanvasRenderingContext2D): void {\n\n        const { gridSize, nodeRadius } = this.props;\n\n        if (ctx) {\n            ctx.clearRect(0, 0, Canvas.WIDTH, Canvas.HEIGHT);\n            \n            ctx.fillStyle = colors.gridLines;\n            ctx.strokeStyle = colors.gridLines;\n            \n            for (let i = 1; i < Canvas.WIDTH / gridSize; i++) {   \n                for (let j = 1; j < Canvas.HEIGHT / gridSize; j++) {\n                    \n                    let xpos = i * gridSize;\n                    let ypos = j * gridSize;\n                    \n                    ctx.beginPath();\n                    ctx.moveTo(0, ypos);\n                    ctx.lineTo(Canvas.WIDTH, ypos);\n                    ctx.stroke();\n            \n                    ctx.beginPath();\n                    ctx.moveTo(xpos, 0);\n                    ctx.lineTo(xpos, Canvas.HEIGHT);\n                    ctx.stroke();\n        \n                    ctx.beginPath();\n                    ctx.arc(i * gridSize, j * gridSize, nodeRadius, 0, 2 * Math.PI);\n                    ctx.fill();\n                    \n                }\n            }\n        }\n        \n    }\n\n    drawCircle(x: number, y: number, r: number, color: string, fill = true, ctx: CanvasRenderingContext2D, lineWidth?: number): void {\n        \n        ctx.save();\n        ctx.beginPath();\n        ctx.arc(x, y, r, 0, 2 * Math.PI, true);\n        \n        if (fill) {\n            ctx.fillStyle = color;\n            ctx.fill();\n        } else {\n            if (lineWidth) {\n                ctx.lineWidth = lineWidth;\n            }\n            ctx.strokeStyle = color;\n            ctx.stroke();\n        }\n\n        ctx.restore();\n    }\n\n    drawVertex(v: Vertex<any>, ctx: CanvasRenderingContext2D): void {\n        \n        const pos: [number, number] = v.getPosition();\n        const { gridSize } = this.props;\n        \n        this.drawCircle(\n            pos[0] * gridSize,\n            pos[1] * gridSize,\n            Canvas.VERTEX_RADIUS,\n            v.getColor(),\n            true,\n            ctx\n        );\n    }\n\n    drawHoverVertex(v: Vertex<any>, ctx: CanvasRenderingContext2D) {\n        this.drawVertex(v, ctx);\n    }\n\n    drawCurrentVertex(v: Vertex<any>, ctx: CanvasRenderingContext2D) {\n        this.drawVertex(v, ctx);\n    }\n\n    drawGraphVertex(v: Vertex<any>, ctx: CanvasRenderingContext2D) {\n        this.drawVertex(v, ctx);\n    }\n\n    drawVertexPosition(v: Vertex<any>, ctx: CanvasRenderingContext2D) {\n        let pos = v.getPosition();\n        let { gridSize } = this.props;\n        let x = pos[0] * gridSize;\n        let y = pos[1] * gridSize;\n\n        ctx.save();\n\n        ctx.translate(x, y);\n\n        // ctx.strokeStyle = 'black';\n        // ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';\n        // ctx.strokeRect(-30, -30, 20, 20);\n        // ctx.fillRect(-30, -30, 20, 20);\n\n        // text   (todo: extract draw text method)\n        let strPos = `(${pos[0]}, ${pos[1]})`;\n        ctx.font = '18px serif';\n        ctx.fillStyle = colors.vertexPosition;\n        ctx.fillText(strPos, -(ctx.measureText(strPos).width + 10), -10);\n        ctx.restore();\n\n        ctx.restore();\n    }\n\n    drawUndirectedEdge(e: Edge<any>, ctx: CanvasRenderingContext2D): void {\n\n        let start = e.start.getPosition();\n        let end = e.end.getPosition();\n        const { gridSize, nodeRadius } = this.props;\n\n        ctx.save();\n        ctx.strokeStyle = e.getColor();\n        ctx.lineWidth = nodeRadius;\n        ctx.beginPath();\n        ctx.moveTo(start[0] * gridSize, start[1] * gridSize);\n        ctx.lineTo(end[0] * gridSize, end[1] * gridSize);\n        ctx.stroke();\n        ctx.restore();\n    }\n\n    // drawUndirectedHoverEdge(e: Edge<any>, ctx: CanvasRenderingContext2D): void {\n    //     // let c = 'rgba(255, 255, 255, 0.3)';\n    //     this.drawUndirectedEdge(e, ctx);\n    // }\n\n    drawDirectedEdge(e: Edge<any>, ctx: CanvasRenderingContext2D): void {\n        this.drawUndirectedEdge(e, ctx);\n        this.drawEdgeArrow(e, ctx);\n    }\n\n    // drawDirectedHoverEdge(e: Edge<any>, ctx: CanvasRenderingContext2D): void {     // rectify alpha channel later.\n    //     this.drawDirectedEdge(e, ctx);\n    // }\n\n    drawEdgeArrow(e: Edge<any>, ctx: CanvasRenderingContext2D) {    // consider: make sprite sheet of all possible rotations to reduce draw cost.\n        let v1 = e.start.getPosition();\n        let v2 = e.end.getPosition();\n\n        let { gridSize } = this.props;\n        let angle = Math.atan2(v2[1] - v1[1], v2[0] - v1[0]);\n        let mag = 10;\n        \n        ctx.save();\n        \n        // if (color) {\n        //     ctx.strokeStyle = ctx.fillStyle = color;\n        // } else {\n        //     ctx.strokeStyle = ctx.fillStyle = Canvas.COLORS.current_node_color;\n        // }\n\n        ctx.strokeStyle = ctx.fillStyle = e.getColor();\n\n        ctx.translate(\n            v2[0] * gridSize - this.props.nodeRadius * Math.cos(angle),\n            v2[1] * gridSize - this.props.nodeRadius * Math.sin(angle)\n        );\n\n        ctx.rotate(angle);\n        \n        ctx.moveTo(-1.4 * mag, 0);\n        ctx.lineTo(-2 * mag, 0.8 * mag);\n        ctx.lineTo(0, 0);\n        ctx.lineTo(-2 * mag, -0.8 * mag);\n        ctx.lineTo(-1.4 * mag, 0);\n        ctx.stroke();\n        ctx.clip();\n        ctx.fill();\n\n        ctx.restore();\n    }\n\n    drawEdgeWeight(e: Edge<any>, round: boolean, ctx: CanvasRenderingContext2D) {\n\n        let v1 = e.start.getPosition();\n        let v2 = e.end.getPosition();\n        let weight: string = e.getWeight().toString();\n        ctx.save();\n    \n        ctx.translate(\n            0.5 * (v2[0] + v1[0]) * this.props.gridSize,\n            0.5 * (v2[1] + v1[1]) * this.props.gridSize\n        );\n        \n        // container\n        if (round) {\n            this.drawCircle(0, 0, 15, colors.edgeWeightBackground, true, ctx);\n            this.drawCircle(0, 0, 15, colors.edgeWeightBorder, false, ctx);\n        } else {\n            ctx.strokeStyle = colors.edgeWeightBorder;\n            ctx.fillStyle = colors.edgeWeightBackground;\n            ctx.strokeRect(-15, -15, 30, 30);\n            ctx.fillRect(-15, -15, 30, 30);\n        }\n\n        // weight\n        ctx.font = '18px serif';\n        ctx.fillStyle = colors.edgeWeight;\n        ctx.fillText(weight, -ctx.measureText(weight).width / 2, 6);\n        ctx.restore();\n    }\n\n    colorEdges(edges: Edge<any>[], color: string) {\n        for (let edge of edges) {\n            edge.setColor(color);\n        }\n\n        if (!this.props.graph.getIsDirected()) {\n            for (let edge of edges) {\n                let reverseEdge = this.props.graph.getEdge(edge.getEnd(), edge.getStart());\n                reverseEdge!.setColor(color);\n            }\n        }\n    }\n    \n    colorVertices(vertices: Vertex<any>[], color: string) {\n        for (let vertex of vertices) {\n            vertex.setColor(color);\n        }\n    }\n    \n    colorFrame(frame: GraphAnimationFrame) {\n        const { \n            redVertices, \n            yellowVertices, \n            greenVertices, \n            redEdges, \n            yellowEdges, \n            greenEdges } = frame;\n\n        // const { graph } = this.props;\n\n        if (redEdges) {\n            this.colorEdges(redEdges, colors.animRed);\n        }\n\n        if (yellowEdges) {\n            this.colorEdges(yellowEdges, colors.animYellow);\n        }\n\n        if (greenEdges) {\n            this.colorEdges(greenEdges, colors.animGreen);\n        }\n\n        if (redVertices) {\n            this.colorVertices(redVertices, colors.animRed);\n        }\n\n        if (yellowVertices) {\n            this.colorVertices(yellowVertices, colors.animYellow);\n        }\n\n        if (greenVertices) {\n            this.colorVertices(greenVertices, colors.animGreen);\n        }\n    }\n    \n    unColorFrame(frame: GraphAnimationFrame) {\n        const { \n            redVertices, \n            yellowVertices, \n            greenVertices, \n            redEdges, \n            yellowEdges, \n            greenEdges } = frame;\n\n        // const { graph } = this.props;\n\n        if (redEdges) {\n            this.colorEdges(redEdges, colors.graphEdge);\n        }\n\n        if (yellowEdges) {\n            this.colorEdges(yellowEdges, colors.graphEdge);\n        }\n\n        if (greenEdges) {\n            this.colorEdges(greenEdges, colors.graphEdge);\n        }\n\n        if (redVertices) {\n            this.colorVertices(redVertices, colors.graphVertex);\n        }\n\n        if (yellowVertices) {\n            this.colorVertices(yellowVertices, colors.graphVertex);\n        }\n\n        if (greenVertices) {\n            this.colorVertices(greenVertices, colors.graphVertex);\n        }\n    }\n}\n\nexport default Canvas;\n\n// Notes:\n/* \nUsing offsetX and offsetY breaks when zooming in with trackpad. (Standard browser zooming works)\nDisable toolbar UI during animations\n*/","export default class Vertex<T> {\n\n    private position: [number, number];\n    private data: T | undefined;\n    private color: string; \n\n    constructor(position: [number, number], color: string, data?: T) {\n        this.position = position;\n        this.data = data;\n        this.color = color;\n    }\n\n    equals(v: Object | null): boolean {\n        if (!(v instanceof Vertex) || v == null) {\n            return false;\n        } else if (this.position[0] === v.position[0] && this.position[1] === v.position[1]) {\n            return true;\n        }\n        return false;\n    }\n\n    getPosition(): [number, number] {\n        return this.position;\n    }\n\n    getData(): T | undefined {\n        return this.data;\n    }\n\n    getColor(): string {\n        return this.color;\n    }\n\n    setColor(color: string): void {\n        this.color = color;\n    }\n    \n    toString(): string {\n        return `x: ${this.position[0]}, y:${this.position[1]}`;\n    }\n\n    hashCode(): number {\n        let hash = 19;\n        hash = 29 * hash + this.position[0];\n        return 31 * hash + this.position[1];\n    }\n}   ","import Vertex from './vertex';\n\nexport default class Edge<T> {\n\n    public start: Vertex<T>;\n    public end: Vertex<T>;\n    private weight: number;\n    private color: string;\n\n    constructor(start: Vertex<T>, end: Vertex<T>, color: string, weight?: number) {\n        this.start = start;\n        this.end = end;\n        this.color = color;\n        \n        if (weight) {\n            this.weight = weight;\n        } else {\n            let p1 = this.start.getPosition();\n            let p2 = this.end.getPosition();\n            // todo: replace with Euclidean Distance method in Grid Component. Extract as utility method.\n            this.weight = parseFloat((Math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)).toFixed(1));  \n        }\n    }\n\n    equals(e: Object): boolean {\n        if (!(e instanceof Edge) || e == null) {\n            return false;\n        } else if (this.start.equals(e.start) && this.end.equals(e.end)) {\n            return true;\n        }\n        return false;\n    }\n\n    getStart(): Vertex<T> {\n        return this.start;\n    }\n\n    setStart(start: Vertex<T>): void {\n        this.start = start;\n    }\n\n    getEnd(): Vertex<T> {\n        return this.end;\n    }\n\n    setEnd(end: Vertex<T>): void {\n        this.end = end;\n    }\n\n    getWeight(): number {\n        return this.weight;\n    }\n\n    getColor(): string {\n        return this.color;\n    }\n\n    setColor(color: string): void {\n        this.color = color;\n    }\n\n    toString(): string {\n        return `start: ${this.start}, end:${this.end}`;\n    }\n\n    hashCode(): number {\n        let hash = 19;\n        hash = 29 * hash + this.start.hashCode();\n        return 31 * hash + this.end.hashCode();\n    }\n}","\nexport function euclideanDist(p1: number[], p2: number[]) {\n    return Math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2);\n}\n\n/**\n * MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/\n * Global_Objects/Math/random#getting_a_random_integer_between_two_values_inclusive\n * @param min \n * @param max \n * @returns \n */\nexport function getRandomInt(min: number, max: number): number {\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\nexport function getRandomBoolean(): boolean {\n    return getRandomInt(0, 1) === 1;\n}\n\n\n/**\n * RNG with skew.\n * https://stackoverflow.com/a/49434653\n * @param min\n * @param max \n * @param skew \n * @returns \n */\nexport function randn_bm(min: number, max: number, skew: number): number {\n    let u = 0, v = 0;\n    while(u === 0) u = Math.random() //Converting [0,1) to (0,1)\n    while(v === 0) v = Math.random()\n    let num = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v )\n    \n    num = num / 10.0 + 0.5 // Translate to 0 -> 1\n    if (num > 1 || num < 0) \n      num = randn_bm(min, max, skew) // resample between 0 and 1 if out of range\n    \n    else{\n      num = Math.pow(num, skew) // Skew\n      num *= max - min // Stretch to fill range\n      num += min // offset to min\n    }\n    return num\n  }\n\nexport function getSkewedRandomBoolean() {\n    let skews = [0.10, 0.20, 0.80, 1.4, 3, 5, 7, 10, 11];\n    return Math.floor(randn_bm(-1, 2, skews[getRandomInt(0, skews.length - 1)]));\n}\n\nexport function getRandomBool() {\n    return Math.floor(Math.pow(1 - getRandomInt(0, 1), 10)) === 1;\n}\n","import React from 'react';\nimport Canvas from './canvas';\n\nimport Vertex from '../graph/vertex';\nimport Edge from '../graph/edge';\nimport Graph from '../graph/graph'\nimport { GraphAnimationFrame } from '../graph/algorithms';\nimport { colors } from '../utils/colors';\nimport { euclideanDist } from '../utils/mathFunctions'\n\ninterface Props {\n    gridSize: number,\n    nodeRadius: number,\n    graph: Graph<any>,\n    isAnimating: boolean,\n    animationFrame: GraphAnimationFrame | null;\n}\n\ninterface State {\n    hoveringVertex: Vertex<any> | null,\n    currentVertex: Vertex<any> | null,\n    hoveringEdge: Edge<any> | null,\n    graph: Graph<any>\n}\n\ninterface GridState {\n    cursor: [number, number],\n    nearestVertexInPixels: [number, number],\n}\n\nclass Grid extends React.Component<Props, State> {\n\n    private gridState: GridState;\n\n    constructor(props: Props) {\n        super(props);\n\n        let graph = this.props.graph\n\n        this.state = {\n            hoveringVertex: null,\n            currentVertex: null,\n            hoveringEdge: null,\n            graph: graph,\n        }\n\n        this.gridState = {\n            cursor: [-1, -1],\n            nearestVertexInPixels: [-1, -1],\n        }\n    }\n\n    handleClick(event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) {\n\n        if (this.props.isAnimating) {\n            return;\n        }\n\n        let {\n            hoveringVertex,\n            hoveringEdge,\n            currentVertex,\n            graph,\n        } = this.state;\n\n        if (hoveringVertex) {\n            if (hoveringVertex.equals(currentVertex)) {\n                this.setState({\n                    currentVertex: null,\n                    hoveringEdge: null\n                });\n            } else {\n                if (hoveringEdge) {\n                    if (!graph.edgeSet.contains(hoveringEdge)) {\n                        graph.insertEdge(hoveringEdge);\n                    } else {\n                        graph.removeEdge(hoveringEdge);\n                    }\n                }\n\n                let newVertex = new Vertex(hoveringVertex.getPosition(), colors.currentVertex);\n                this.setState({\n                    currentVertex: newVertex,\n                    hoveringEdge: null\n                });\n            }\n\n            if (!graph.vertexSet.contains(hoveringVertex)) {\n                graph.insertVertex(hoveringVertex);\n            }\n        }\n    }\n\n    handleRightClick(event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) {\n        \n        event.preventDefault();\n\n        if (this.props.isAnimating) {\n            return;\n        }\n\n        let {\n            hoveringVertex,\n            graph\n        } = this.state;\n\n        if (hoveringVertex) {\n            if (graph.vertexSet.contains(hoveringVertex)) {\n                graph.removeVertex(hoveringVertex);\n                this.setState({\n                    currentVertex: null,\n                    hoveringEdge: null\n                });\n            }\n        }\n    }\n\n    handleMouseMove(event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) {\n\n        if (this.props.isAnimating) {\n            return;\n        }\n\n        let prevNearestVertexInPixels = this.gridState.nearestVertexInPixels;\n        this.gridState.cursor = [event.nativeEvent.offsetX, event.nativeEvent.offsetY];\n\n        if (this.nearestVertexInPixels(this.gridState.cursor)[0] !== prevNearestVertexInPixels[0] || \n            this.nearestVertexInPixels(this.gridState.cursor)[1] !== prevNearestVertexInPixels[1]) {\n                this.gridState.nearestVertexInPixels = this.nearestVertexInPixels(this.gridState.cursor);\n\n                if (this.state.currentVertex) {\n                    let hoveringEdge = new Edge(this.state.currentVertex, this.PixelsToVertex(this.gridState.nearestVertexInPixels, colors.hoverVertex), colors.hoverEdge);\n                    this.setState({\n                        hoveringEdge: hoveringEdge\n                    });\n                }\n            }\n        \n        if (this.inVertexRadius(this.gridState.cursor)) {\n    \n            if (!this.state.hoveringVertex) {\n                this.setState({\n                    hoveringVertex: this.PixelsToVertex(this.gridState.nearestVertexInPixels, colors.hoverVertex)\n                });\n            }\n\n        } else {\n            \n            if (this.state.hoveringVertex) {\n                this.setState({\n                    hoveringVertex: null\n                });\n            }\n        }\n\n    }\n\n    render() {\n        return (<Canvas \n          gridSize={this.props.gridSize}\n          nodeRadius={this.props.nodeRadius}\n          hoveringVertex={this.state.hoveringVertex}\n          hoveringEdge={this.state.hoveringEdge}\n          currentVertex={this.state.currentVertex}\n          graph={this.state.graph}\n          animationFrame={this.props.animationFrame}\n\n          onClick={(event) => this.handleClick(event)}\n          handleRightClick={(event) => this.handleRightClick(event)}\n          onMouseMove={(event) => this.handleMouseMove(event)}\n        />);\n    }\n\n    // utility methods\n\n    PixelsToVertex(point: [number, number], color: string): Vertex<any> {\n        let vertexPoint = point.map((val) => val / this.props.gridSize);\n        return new Vertex([vertexPoint[0], vertexPoint[1]], color);\n    }\n\n    /**\n     * \n     * @param cursor size 2 array where cursor[0] = cursorX, cursor[1] = cursorY; pixel position on canvas element.\n     * @returns pixel position of nearest vertex relative to cursor position on grid as size 2 array.\n     */\n     nearestVertexInPixels(cursor: [number, number]): [number, number] {\n        \n        const { gridSize } = this.props;\n        let nearest: number[] = cursor.map((val) => Math.round(val / gridSize) * gridSize)\n        let nearestPixelNode: [number, number] = [nearest[0], nearest[1]];\n        \n        switch (nearestPixelNode[0]) {\n            case 0:\n                nearestPixelNode[0] += gridSize;\n                break;\n            case Canvas.WIDTH:\n                nearestPixelNode[0] -= gridSize;\n                break;\n            default:\n                break;\n        }\n\n        switch (nearestPixelNode[1]) {\n            case 0:\n                nearestPixelNode[1] += gridSize;\n                break;\n            case Canvas.HEIGHT:\n                nearestPixelNode[1] -= gridSize;\n                break;\n            default:\n                break;\n        }\n\n        return nearestPixelNode;\n    }\n\n    inVertexRadius(cursor: [number, number]): boolean {\n        let nearestVertex: [number, number] = this.nearestVertexInPixels(cursor);\n        if (nearestVertex[0] > 0 && nearestVertex[0] < Canvas.WIDTH && nearestVertex[1] > 0 && nearestVertex[1] < Canvas.HEIGHT) {\n            return euclideanDist(cursor, nearestVertex) < Canvas.VERTEX_RADIUS;\n        }\n        return false;\n    }\n\n}\n\nexport default Grid;","import { Hashable } from \"./hashable\";\n\n// TODO: See deductions and rectify!\n\nexport default class HashMap<K extends Hashable, V> {\n\n    private table: (MapEntry<K, V> | null)[];\n    private size: number;\n    private length: number;\n\n    public static readonly INITIAL_CAPACITY = 13;\n    public static readonly MAX_LOAD_FACTOR = 0.75;\n\n    constructor() {\n        this.table = new Array<MapEntry<K, V> | null>(HashMap.INITIAL_CAPACITY);\n        this.length = HashMap.INITIAL_CAPACITY;\n        this.size = 0;\n    }\n\n    public put(key: K, value: V): V | null {\n        // exceptions\n        if (key == null) {\n            throw new Error(\"Key is null.\");\n        } else if (value == null) {\n            throw new Error(\"Value is null.\");\n        }\n\n        // load factor check\n        if ((this.size + 1) / (this.length) > HashMap.MAX_LOAD_FACTOR) {\n            this.resizeBackingTable(2 * this.length + 1);\n        }\n\n        // index corresponding to key in the table\n        let index: number = this.hashAndCompression(key);\n        let current: MapEntry<K, V> | null = this.table[index];\n\n        // duplicate check\n        while (current != null && !current.getKey().equals(key)) {\n            current = current.getNext();\n        }\n\n        // current == null <-> unique entry\n        if (current == null) {\n            this.table[index] = new MapEntry<K, V>(key, value, this.table[index]);\n            this.size++;\n            return null;\n        }\n        // current != null <-> duplicate entry\n        let oldValue: V = current.getValue();\n        // current.setKey(key);    // replace key reference;\n        current.setValue(value);\n        return oldValue;\n    }\n\n    public remove(key: K): V {\n        if (key == null) {\n            throw new Error(\"Given key is null.\");\n        }\n        let index = this.hashAndCompression(key);\n        let current: MapEntry<K, V> | null = this.table[index];\n\n        if (current == null) {\n            throw new Error(`Key: ${key} not in map.`);\n        }\n\n        let toRemove: V | null = null;\n        \n        if (current.getKey().equals(key)) {\n            toRemove = current.getValue();\n            this.table[index] = current.getNext();\n            this.size--;\n            return toRemove;\n        }\n\n        while (current != null && current.getNext() != null) {\n            if (current.getNext()!.getKey().equals(key)) {\n                toRemove = current.getNext()!.getValue();\n                current.setNext(current.getNext()!.getNext());\n                this.size--;\n                break;\n            }\n            current = current.getNext();\n        }\n\n        if (toRemove == null) {\n            throw new Error(`Key: ${key} not in map.`);\n        }\n\n        return toRemove;\n    }\n\n    public get(key: K): V {\n        if (key == null) {\n            throw new Error(\"Key is null.\");\n        }\n        let index = this.hashAndCompression(key);\n        let current = this.table[index];\n\n        while (current != null) {\n            if (current.getKey().equals(key)) {\n                return current.getValue();\n            }\n            current = current.getNext();\n        }\n        throw new Error(\"Key: \" + key + \" not in map.\");\n    }\n\n    public getKey(key: K): K | null {  // get reference contained within map.\n        if (key == null) {\n            throw new Error(\"Key is null.\");\n        }\n        let index = this.hashAndCompression(key);\n        let current = this.table[index];\n\n        while (current != null) {\n            if (current.getKey().equals(key)) {\n                return current.getKey();\n            }\n            current = current.getNext();\n        }\n        // throw new Error(\"Key: \" + key + \" not in map.\");\n        return null;\n    }\n\n    public containsKey(key: K): boolean {\n        if (key == null) {\n            throw new Error(\"Key is null.\");\n        }\n        let index = this.hashAndCompression(key);\n        let current = this.table[index];\n        while (current != null) {\n            if (current.getKey().equals(key)) {\n                return true;\n            }\n            current = current.getNext();\n        }\n        return false;\n    }\n\n    public keySet(): K[] {\n    // public keySet(): HashSet<K> {\n        \n        // let keys = new HashSet<K>();\n        let keys: K[] = [];\n        for (let entry of this.table) {\n            if (entry) {\n                let current: MapEntry<K, V> | null = entry;\n                while (current != null) {\n                    keys.push(current.getKey());\n                    current = current.getNext();\n                }\n            }\n\n            // break on keys.size() == size\n            // if (keys.getSize() === this.size) {\n            if (keys.length === this.size) {\n                break;      // prevents traversal of additional null values in table base array.\n            }\n        }\n\n        return keys;\n    }\n\n    public values(): V[] {\n        let values = [];\n        for (let entry of this.table) {\n            if (entry) {\n                let current: MapEntry<K, V> | null = entry;\n                while (current != null) {\n                    values.push(current.getValue());\n                    current = current.getNext();\n                }\n            }\n            if (values.length === this.size) {\n                break;      // prevents traversal of additional null values in table base array.\n            }\n        }\n\n        return values;\n    }\n\n    public getSize() {\n        return this.size;\n    }\n\n    public clear(): void {\n        this.table = new Array<MapEntry<K, V> | null>(HashMap.INITIAL_CAPACITY);\n        this.length = HashMap.INITIAL_CAPACITY;\n        this.size = 0;\n    }\n\n    private resizeBackingTable(length: number): void {\n        \n        if (length < this.size) {\n            throw new Error(`Length: ${length} is less than current size of hash map.`);\n        }\n\n        // if length == table.length, new table will remain unchanged after 'resize'.\n        if (length === this.length) {\n            return;\n        }\n\n        // initialize new array.\n        let oldTable: (MapEntry<K, V> | null)[] = this.table;\n        this.table = new Array<MapEntry<K, V>>(length);\n        this.length = length;\n        let counter = 0;\n\n        // hash and compress elements iteratively and add to new array.\n        for (let head of oldTable) {\n            if (head) {\n                let current: MapEntry<K, V> | null = head;\n                \n                while (current) {\n                    let key: K = current.getKey();\n                    let value: V = current.getValue();\n                    let index = this.hashAndCompression(key);\n                    this.table[index] = new MapEntry<K, V>(key, value, this.table[index]);\n                    counter++;\n                    current = current.getNext();\n                }\n            }\n\n            if (counter === this.size) {\n                return;\n            }\n        }\n    }\n\n    private hashAndCompression(key: K): number {\n        return Math.abs(key.hashCode() % this.length);\n    }\n}\n\n\nclass MapEntry<K extends Hashable, V> {\n\n    private key: K;\n    private value: V;\n    private next: MapEntry<K, V> | null;\n\n    /**\n     * Constructs a new MapEntry with the given key, value, and next reference.\n     *\n     * @param key   the key in the new entry\n     * @param value the value in the new entry\n     * @param next  the next entry in the external chain\n     */\n    constructor(key: K, value: V, next: MapEntry<K, V> | null) {\n        this.key = key;\n        this.value = value;\n        if (next) {\n            this.next = next;\n        } else {\n            this.next = null;\n        }\n    }\n\n    public getKey(): K {\n        return this.key;\n    }\n\n    public getValue(): V {\n        return this.value;\n    }\n\n    public getNext(): MapEntry<K, V> | null {\n        return this.next;\n    }\n\n    public setKey(key: K): void {\n        this.key = key;\n    }\n\n    public setValue(value: V): void {\n        this.value = value;\n    }\n\n    public setNext(next: MapEntry<K, V> | null): void {\n        this.next = next;\n    }\n\n    public toString(): string {\n        let key: string = this.key.toString();\n        let value: V = this.value;\n        return `(${key}, ${value})`;\n    }\n\n    public equals(obj: object): boolean {\n        if (!(obj instanceof MapEntry)) {\n            return false;\n        } else {\n            // let other: MapEntry<K, V> = obj as MapEntry<K, V>;\n            return obj.getKey().equals(this.key) && obj.getValue().equals(this.value);\n        }\n    }\n}","import { Hashable } from './hashable'\nimport HashMap from './hashMap';\n\n/**\n * HashSet based on the Java Implementation of the same\n */\nexport default class HashSet<E extends Hashable> {\n    private static readonly PRESENT: Object = {};\n    private map: HashMap<E, Object>;\n    \n    constructor() {\n        this.map = new HashMap();\n    }\n\n    public add(data: E): void {\n        this.map.put(data, HashSet.PRESENT);\n    }\n\n    public remove(data: E) {\n      return this.map.remove(data);\n    }\n\n    public get(data: E): E | null {    // get reference contained within set.\n        return this.map.getKey(data);\n    }\n\n    public contains(data: E): boolean {\n        return this.map.containsKey(data);\n    }\n\n    public getSet(): E[] {\n        return this.map.keySet();\n    }\n\n    getSize(): number {\n        return this.map.getSize();\n    }\n\n    clear(): void {\n        this.map = new HashMap();\n    }\n\n    toString(): string {\n        return this.getSet().toString();\n    }\n}","import Vertex from \"./vertex\";\nimport Edge from \"./edge\";\nimport HashSet from \"../utils/hashSet\";\nimport HashMap from \"../utils/hashMap\";\nimport { Equatable } from \"../utils/hashable\";\nimport { colors } from \"../utils/colors\";\n\n/**\n * Adjacency Map (modified) Implementation of Goodrich, Tamassia, Goldwasser's Graph ADT. (Data Structures and Algorithms in Java)\n */ \nexport default class Graph<T> {\n    \n    private isDirected: boolean;\n    private showWeights: boolean;   // canvas rendering \n    private showPositions: boolean; // canvas rendering \n    public vertexSet: HashSet<Vertex<T>>;   // make private. Use this.references in canvas.\n    public edgeSet: HashSet<Edge<T>>;\n    private adjacencyMap: HashMap<Vertex<T>, IncidenceMapInterface<T>>;     // ?use linked positional list for vertices \n\n    constructor(isDirected: boolean, showWeights: boolean, showPositions: boolean) {\n        this.isDirected = isDirected;\n        this.showWeights = showWeights;\n        this.showPositions = showPositions;\n\n        this.vertexSet = new HashSet();\n        this.edgeSet = new HashSet();\n        this.adjacencyMap = new HashMap();\n    }\n\n    numVertices(): number  {\n        return this.vertexSet.getSize();\n    }\n\n    numEdges(): number {\n        return this.edgeSet.getSize();\n    }\n\n    vertices(): Vertex<T>[] {\n        return this.vertexSet.getSet();\n    }\n\n    edges(): Edge<T>[] {\n        return this.edgeSet.getSet();\n    }\n\n    getEdge(u: Vertex<T>, v: Vertex<T>): Edge<T> | null {\n        try {\n            return this.adjacencyMap.get(u).outgoing.get(v);\n        } catch {\n            return null;\n        }\n    }\n\n    endVertices(e: Edge<T>): Vertex<T>[] {\n        return [e.getStart(), e.getEnd()];\n    }\n\n    opposite(v: Vertex<T>, e: Edge<T>) {\n        if (v.equals(e.getStart())) {\n            return e.getEnd();\n        } else if (v.equals(e.getEnd())) {\n            return e.getStart();\n        } else {\n            throw new Error(`${e} not incident to ${v}`);\n        }\n    }\n\n    outDegree(v: Vertex<T>): number {\n        return this.adjacencyMap.get(v).outgoing.getSize();\n    }\n\n    inDegree(v: Vertex<T>): number {\n        return this.adjacencyMap.get(v).incoming.getSize();\n    }\n\n    outgoingEdges(v: Vertex<T>): Edge<T>[] {\n        return this.adjacencyMap.get(v).outgoing.values();\n    }\n\n    incomingEdges(v: Vertex<T>): Edge<T>[] {\n        return this.adjacencyMap.get(v).incoming.values();\n    }\n\n    insertVertex(v: Vertex<T>): void {\n        if (this.vertexSet.contains(v)) {\n            return;\n        }\n        \n        v.setColor(colors.graphVertex);\n        this.vertexSet.add(v);\n        this.adjacencyMap.put(v, new IncidenceMap<T>());\n    }\n\n    insertEdge(e: Edge<T>): void {\n        this.insertEdgeHelper(e);\n\n        if (!this.isDirected) {\n            this.insertEdgeHelper(new Edge(e.getEnd(), e.getStart(), e.getColor()));\n        }\n    }\n\n    private insertEdgeHelper(e: Edge<T>): void {\n        if (this.edgeSet.contains(e)) {\n            return;\n        }\n\n        let a = e.getStart();\n        let b = e.getEnd();\n\n        if (this.vertexSet.contains(a)) {\n            e.setStart(this.vertexSet.get(a)!);\n        } else {\n            a.setColor(colors.graphVertex);\n            this.insertVertex(a);\n        }\n\n        if (this.vertexSet.contains(b)) {\n            e.setEnd(this.vertexSet.get(b)!);\n        } else {\n            b.setColor(colors.graphVertex);\n            this.insertVertex(b);\n        }\n\n        let u = e.getStart();\n        let v = e.getEnd();\n\n        e.setColor(colors.graphEdge);\n        this.edgeSet.add(e);\n\n        this.adjacencyMap.get(u).outgoing.put(v, e);\n        this.adjacencyMap.get(v).incoming.put(u, e);\n    }\n\n    /**\n     * Removes Vertex v and all its incident edges in (deg(v)) time.\n     * @param v \n     */\n    removeVertex(v: Vertex<T>): void {  // return removed Vertex?\n        this.vertexSet.remove(v);\n\n        let incidenceMap = this.adjacencyMap.get(v);\n        \n        for (let edge of incidenceMap.incoming.values()) {\n            this.removeEdge(edge);\n        }\n        \n        for (let edge of incidenceMap.outgoing.values()) {\n            this.removeEdge(edge);\n        }\n\n        this.adjacencyMap.remove(v);\n\n    }\n\n    /**\n     * Removes edge e from the graph in O(1) time.\n     * @param e \n     */\n    removeEdge(e: Edge<T>): void {\n        this.edgeSet.remove(e);\n\n        let u = e.getStart();\n        let v = e.getEnd();\n\n        // remove from u.outgoing\n        this.adjacencyMap.get(u).outgoing.remove(v);\n        // remove from v.incoming\n        this.adjacencyMap.get(v).incoming.remove(u);\n\n        if (!this.isDirected) {     // commenting block out fixed the issue of removing reverse edges. Inspect this.\n            // remove from u.incoming\n            this.adjacencyMap.get(u).incoming.remove(v);\n            // remove from v.outgoing\n            this.adjacencyMap.get(v).outgoing.remove(u);\n            // remove from edgeSet\n            let reverseEdge = new Edge(e.getEnd(), e.getStart(), e.getColor());\n            this.edgeSet.remove(reverseEdge);\n        }\n    }\n\n    clear(): void {\n        this.vertexSet = new HashSet();\n        this.edgeSet = new HashSet();\n        this.adjacencyMap = new HashMap();\n    }\n\n    getAdjacencyMap(): HashMap<Vertex<T>, IncidenceMap<T>> {     // for debugging.\n        return this.adjacencyMap;\n    }\n\n    getIsDirected(): boolean {\n        return this.isDirected;\n    }\n\n    setIsDirected(isDirected: boolean): void {\n        \n        if (this.isDirected && !isDirected) {\n            // add reverse edges.\n            for (let edge of this.edgeSet.getSet()) {\n                let reverseEdge = new Edge(edge.getEnd(), edge.getStart(), edge.getColor());\n                this.insertEdge(reverseEdge);\n            }\n        }\n\n        this.isDirected = isDirected;\n    }\n\n    getShowWeights(): boolean {\n        return this.showWeights;\n    }\n\n    setShowWeights(showWeights: boolean): void {\n        this.showWeights = showWeights;\n    }\n\n    getShowPositions(): boolean {\n        return this.showPositions;\n    }\n\n    setShowPositions(showPositions: boolean): void {\n        this.showPositions = showPositions;\n    }\n}\n\ninterface IncidenceMapInterface<T> {\n    incoming: HashMap<Vertex<T>, Edge<T>>,\n    outgoing: HashMap<Vertex<T>, Edge<T>>, \n    equals: (obj: object) => boolean\n}\n\nclass IncidenceMap<T> implements IncidenceMapInterface<T>, Equatable {\n    public incoming: HashMap<Vertex<T>, Edge<T>>\n    public outgoing: HashMap<Vertex<T>, Edge<T>>\n    \n    constructor() {\n        this.incoming = new HashMap();\n        this.outgoing = new HashMap();\n    }\n\n    equals(obj: Object): boolean {\n        if (!(obj instanceof IncidenceMap) || obj == null) {\n            return false;\n        }\n        return this.incoming === obj.incoming && this.outgoing === obj.outgoing;    // reference equality.\n    }\n} \n\n","export default class Queue<T> {\n    private arr: T[];\n    \n    constructor() {\n        this.arr = [];\n    }\n\n    enqueue(element: T): void {\t\n        this.arr.push(element);\n    }\n\n    dequeue(): T {    \n        let first = this.arr.shift();\n        if (first) {\n            return first;\n        } else {\n            throw new Error(\"Underflow.\");\n        }\n    }\n\n    peekFirst(): T | null {\n        if(this.isEmpty()) {\n            return null;\n        }\n        return this.arr[0];\n    }\n\n    isEmpty(): boolean {\n        return this.arr.length === 0;\n    }\n\n}","import HashSet from \"../utils/hashSet\";\n// import Stack from \"../utils/stack\";\nimport Queue from \"../utils/queue\";\nimport Graph from \"./graph\";\nimport Vertex from \"./vertex\";\nimport Edge from \"./edge\";\nimport HashMap from \"../utils/hashMap\";\n\nexport function breadthFirstSearch(graph: Graph<any>, startVertex: Vertex<any>): AnimationBuilder {\n\n    let animation = new AnimationBuilder();\n    let visited = new HashSet<Vertex<any>>();\n    let discovery: Edge<any>[] = [];\n    let queue = new Queue<Vertex<any>>();\n    \n    queue.enqueue(startVertex);\n    \n    while (!queue.isEmpty()) {\n        let currentVertex = queue.dequeue();\n        if (!visited.contains(currentVertex)) {\n            \n            animation.addFrame({ outlineVertices: [currentVertex], redVertices: visited.getSet(), redEdges: discovery });\n            visited.add(currentVertex);\n            \n            animation.addFrame({ outlineVertices: [currentVertex], redVertices: visited.getSet(), redEdges: discovery });\n            animation.addFrame({ \n                outlineVertices: [currentVertex], \n                redVertices: visited.getSet(), \n                redEdges: discovery,\n                yellowEdges: graph.outgoingEdges(currentVertex), \n            });\n\n            for (let edge of graph.outgoingEdges(currentVertex)) {\n                let opposite = graph.opposite(currentVertex, edge);\n                discovery.push(...graph.outgoingEdges(currentVertex));\n                queue.enqueue(opposite);\n            }\n        }\n    }\n    animation.addFrame({ redVertices: visited.getSet(), redEdges: discovery });\n\n    return animation;\n}\n\nexport function recursiveDepthFirstSearch(graph: Graph<any>, startVertex: Vertex<any>): AnimationBuilder {\n    let animation = new AnimationBuilder();\n    let visited = new HashSet<Vertex<any>>();\n    let discovery = new HashMap<Vertex<any>, Edge<any>>();\n    dfsHelper(graph, startVertex, visited, discovery, animation);\n    return animation;\n}\n\nfunction dfsHelper(graph: Graph<any>, u: Vertex<any>, \n    visitedVertices: HashSet<Vertex<any>>, discoveryEdges: HashMap<Vertex<any>, Edge<any>>, animation: AnimationBuilder) {\n    \n    visitedVertices.add(u);\n    animation.addFrame({ \n        outlineVertices: [u], \n        redVertices: visitedVertices.getSet(), \n        redEdges: discoveryEdges.values(),\n    })\n\n    for (let edge of graph.outgoingEdges(u)) {\n        let v: Vertex<any> = graph.opposite(u, edge);\n        if (!visitedVertices.contains(v)) {\n            discoveryEdges.put(v, edge);\n            animation.addFrame({ \n                outlineVertices: [u], \n                redVertices: visitedVertices.getSet(), \n                redEdges: discoveryEdges.values(), \n                yellowEdges: graph.outgoingEdges(u) \n            });\n\n            dfsHelper(graph, v, visitedVertices, discoveryEdges, animation);\n            animation.addFrame({ \n                outlineVertices: [u], \n                redVertices: visitedVertices.getSet(), \n                redEdges: discoveryEdges.values(), \n            })\n\n        }\n    }\n}\n\nexport class AnimationBuilder {\n    private frames: GraphAnimationFrame[];\n\n    constructor() {\n        this.frames = [];\n    }\n\n    public addFrame(frame: GraphAnimationFrame) {\n        this.frames.push(this.cloneFrame(frame));\n    }\n\n    public getFrames(): GraphAnimationFrame[] {\n        return this.frames;\n    }\n\n    private cloneArray(arr: any[] | null | undefined): any[] | null {\n        return arr ? arr.slice(0, arr.length): null;\n    }\n\n    private cloneFrame(frame: GraphAnimationFrame): GraphAnimationFrame {\n        // todo: explore ways to 'object map'\n        return {\n            outlineVertices: this.cloneArray(frame.outlineVertices),\n            redVertices: this.cloneArray(frame.redVertices),\n            redEdges: this.cloneArray(frame.redEdges),\n            yellowVertices: this.cloneArray(frame.yellowVertices),\n            yellowEdges: this.cloneArray(frame.yellowEdges),\n            greenVertices: this.cloneArray(frame.greenEdges),\n            greenEdges: this.cloneArray(frame.greenEdges)\n        }\n    }\n}\n\nexport interface GraphAnimationFrame {\n    outlineVertices?: Vertex<any>[] | null,\n    redVertices?: Vertex<any>[] | null,\n    redEdges?: Edge<any>[] | null,\n    yellowVertices?: Vertex<any>[] | null,\n    yellowEdges?: Edge<any>[] | null,\n    greenVertices?: Vertex<any>[] | null,\n    greenEdges?: Edge<any>[] | null\n}\n\n// function dfsHelper(graph: Graph<any>, startVertex: Vertex<any>, \n//     visited: HashSet<Vertex<any>>, discovery: HashSet<Edge<any>>, animation: AnimationBuilder): void {\n\n//     // TODO: record discovery edges.\n\n//     // mark start as visited;\n//     // animation.addFrame(visited.getSet(), startVertex, discovery.getSet());\n//     visited.add(startVertex);\n//     animation.addFrame(visited.getSet(), startVertex, discovery.getSet(), null);\n//     // for each of start's outgoing edges:\n//     for (let edge of graph.outgoingEdges(startVertex)) {\n//         // if (other endpoint is not visited):\n//         let opposite = graph.opposite(startVertex, edge);\n//         if (!visited.contains(opposite)) {\n//             // depthFirstSearch(other endpoint of edge);\n//             discovery.add(edge);\n//             animation.addFrame(visited.getSet(), startVertex, discovery.getSet(), graph.outgoingEdges(startVertex));\n//             // display outgoing edges.\n//             // set explorationEdge(edge)\n//             // animation.addFrame(visited.getSet(), discoveryEdges.getSet(), graph.outgoingEdges(startVertex));\n//             dfsHelper(graph, opposite, visited, discovery, animation);\n//             animation.addFrame(visited.getSet(), startVertex, discovery.getSet(), null);\n//         }\n//     }  \n// }\n\n/*\nOne frame of DFS:\n    actual graph: taken care of by Canvas ComponentDidUpdate\n\n    start vertex: default is first inserted vertex, (todo:) can be changed through toolbar\n    current vertex: the one dfs is called recursively on\n    outgoing edges from current vertex: adjMap\n    visited vertices: maintain a collection\n    discovery edges: maintain a collection\n\n*/\n// export function iterativeDepthFirstSearch(graph: Graph<any>, startVertex: Vertex<any>): AnimationBuilder {\n//     let visited = new HashSet<Vertex<any>>();\n//     let discovery = new HashMap<Vertex<any>, Edge<any>>();\n//     let animation = new AnimationBuilder();\n//     let stack = new Stack<Vertex<any>>();\n\n//     stack.push(startVertex);\n\n//     while (!stack.isEmpty()) {\n//         let u = stack.pop();\n\n//         // animation.addFrame({ outlineVertices: [u], redVertices: visited.getSet(), redEdges: discovery.values() })\n//         visited.add(u);\n//         // animation.addFrame({ outlineVertices: [u], redVertices: visited.getSet(), redEdges: discovery.values() })\n\n//         for (let edge of graph.outgoingEdges(u)) {\n//             let v: Vertex<any> = graph.opposite(u, edge);\n//             if (!visited.contains(v)) {\n//                 discovery.put(v, edge);\n//                 stack.push(v);\n//             }\n//         }\n//     }\n    \n//     return animation;\n// }\n","import React from 'react';\nimport './App.css';\n\nimport Toolbar from './components/toolbar';\nimport Grid from './components/grid';\nimport Graph from './graph/graph';\nimport { recursiveDepthFirstSearch, breadthFirstSearch, AnimationBuilder, GraphAnimationFrame } from './graph/algorithms';\nimport Vertex from './graph/vertex';\nimport Edge from './graph/edge';\nimport { getRandomBoolean, getRandomInt } from './utils/mathFunctions';\nimport { colors } from './utils/colors';\n\ninterface Props {\n\n}\n\ninterface State {\n    gridSize: number,\n    animationSpeed: number\n    graph: Graph<any>,\n    isAnimating: boolean,\n    animationFrame: GraphAnimationFrame | null,\n    algorithm: string\n}\n\ninterface IDAlgorithmMap {\n    [key: string]: (graph: Graph<any>, startVertex: Vertex<any>) => AnimationBuilder\n}\n\nclass App extends React.Component<Props, State> {\n\n    // private gridSizeValues: number[] = [100, 80, 40, 32, 25, 20, 16];\n    // private gridSizeValues: number[] = [100, 80, 40];\n    private gridSizeValues: number[] = [100, 80];\n    private animationSpeeds: number[] = [2000, 1000, 500, 400, 200, 100, 50, 20];\n    private algorithms: IDAlgorithmMap;\n\n    constructor(props: Props) {\n        super(props);\n\n        this.onDirected = this.onDirected.bind(this);\n        this.onShowWeights = this.onShowWeights.bind(this);\n        this.onShowPositions = this.onShowPositions.bind(this);\n        this.onGridSizeChange = this.onGridSizeChange.bind(this);\n        this.onGenerateGrid = this.onGenerateGrid.bind(this);\n        this.onGenerateRandom = this.onGenerateRandom.bind(this);\n        this.onClear = this.onClear.bind(this);\n        this.onSelection = this.onSelection.bind(this);\n        this.onAnimationSpeedChange = this.onAnimationSpeedChange.bind(this);\n        this.onStart = this.onStart.bind(this);\n\n        // testing\n        this.onTest = this.onTest.bind(this);\n\n        this.algorithms = {\n            'dfs': recursiveDepthFirstSearch,\n            'bfs': breadthFirstSearch\n        }\n\n        this.state = {\n            gridSize: 0,\n            animationSpeed: 2,\n            graph: new Graph(false, false, false),\n            isAnimating: false,\n            animationFrame: null,\n            algorithm: Object.keys(this.algorithms)[0]\n        }    \n    }\n\n    componentDidMount() {\n        // this.onTest();\n    }\n\n    onDirected(directedEdges: boolean) {\n        this.state.graph.setIsDirected(directedEdges);\n        this.setState({});\n    }\n\n    onShowWeights(showWeights: boolean) {\n        this.state.graph.setShowWeights(showWeights);\n        this.setState({});\n    }\n\n    onShowPositions(showPositions: boolean) {\n        this.state.graph.setShowPositions(showPositions);\n        this.setState({});\n    }\n\n    onGridSizeChange(sliderValue: number) {\n        this.setState({gridSize: sliderValue});\n    }\n\n    onGenerateRandom() {\n        let gridSize = this.gridSizeValues[this.state.gridSize];    // todo: state holds gridSize rather than index\n        let hdivs: number = 1600 / gridSize;\n        let vdivs: number = 800 / gridSize;\n\n        this.state.graph.clear();\n\n        let xstep = [1, 2, 3, 4][getRandomInt(0, 3)];\n        let ystep = [1, 2, 3, 4][getRandomInt(0, 3)];\n\n        for (let y = 1; y < vdivs; y += ystep) {\n            for (let x = 1; x < hdivs; x += xstep) {\n                if (getRandomBoolean() && getRandomBoolean()) {\n                    this.state.graph.insertVertex(new Vertex([x, y], colors.graphVertex));\n                }\n            }\n        }\n\n        for (let u of this.state.graph.vertices()) {\n            for (let v of this.state.graph.vertices()) {\n                if (getRandomBoolean() && getRandomBoolean() && getRandomBoolean() && !u.equals(v)) {\n                    this.state.graph.insertEdge(new Edge(u, v, colors.graphEdge));\n                }\n            }\n        }\n\n        this.setState({});\n\n    }\n\n    onGenerateGrid() {\n        let gridSize = this.gridSizeValues[this.state.gridSize];\n        let hdivs: number = 1600 / gridSize;\n        let vdivs: number = 800 / gridSize;\n\n        this.state.graph.clear();\n\n        for (let y = 1; y < vdivs; y++) {\n            for (let x = 1; x < hdivs; x++) {\n                let s = new Vertex([x, y], colors.graphVertex);\n                let r = new Vertex([x + 1, y], colors.graphVertex);\n                let d = new Vertex([x, y + 1], colors.graphVertex);\n                let right = new Edge(s, r, colors.graphEdge);\n                let down = new Edge(s, d, colors.graphEdge);\n                if (x !== hdivs - 1) {\n                    this.state.graph.insertEdge(right);\n                }\n\n                if (y !== vdivs - 1)  {\n                    this.state.graph.insertEdge(down);\n                }\n            }\n        }\n\n        this.setState({});\n    }\n\n    onClear() {\n        this.state.graph.clear();\n        this.setState({});\n    }\n\n    onSelection(option: string) {\n        this.setState({ algorithm: option })\n    }\n\n    onAnimationSpeedChange(sliderValue: number) {\n        this.setState({ animationSpeed: sliderValue });\n    }\n\n    onStart() {\n\n        let intervalDelay = this.animationSpeeds[this.state.animationSpeed];\n\n        if (this.state.graph.vertices().length === 0) {\n            return;\n        }\n\n        this.setState({isAnimating: true});\n\n        let frames = this.algorithms[this.state.algorithm](this.state.graph, this.state.graph.vertices()[0]).getFrames();\n\n        for (let i = 0; i < frames.length; i++) {\n            // if (i === frames.length - 1) {\n            //     let lastFrame = frames[i];\n            //     if (lastFrame.redVertices) {\n            //         for (let vertex of lastFrame.redVertices) {\n            //             if (!this.state.graph.vertices().includes(vertex)) {\n            //                 console.log(vertex.toString());\n            //             }\n            //         }\n            //     }\n            // }\n            setTimeout(() => {\n                this.setState({\n                    animationFrame: frames[i]\n                });\n            }, (i + 1) * intervalDelay);\n        }\n\n        // use requestAnimationFrame or recursive setTimout.\n        setTimeout(() => {this.setState({isAnimating: false, animationFrame: null})}, ((frames.length + 1) * intervalDelay) + 3000);\n        // setTimeout(() => {this.setState({isAnimating: false, animationFrame: frames[frames.length - 1]})}, ((frames.length + 1) * intervalDelay) + 3000);\n    }\n\n    onTest() {\n        console.log('testing.');\n        // this.test1();\n        // this.test2();\n        console.log('end of test.')\n    }\n\n    test1() {\n        let vertices = this.state.graph.vertices();\n        let edges = this.state.graph.edges();\n\n        console.log(vertices);\n        console.log(edges);\n\n        for (let vertex of vertices) {\n            vertex.setColor(colors.animBlue);\n        }\n\n        for (let edge of edges) {\n            edge.setColor(colors.animBlue);\n        }\n        this.setState({});\n    }\n\n    test2() {\n        this.onGenerateGrid();\n        let vertices = this.state.graph.vertices();\n        let map = this.state.graph.getAdjacencyMap();\n\n        let i = 0;\n        let o = 0;\n\n        for (let v of vertices) {\n            let iMap = map.get(v);\n            for (let u of iMap.incoming.keySet()) {\n                if (vertices.includes(u)) {\n                    console.log(u.toString());\n                    i++;\n                }\n            }\n\n            for (let u of iMap.outgoing.keySet()) {\n                if (vertices.includes(u)) {\n                    console.log(u.toString());\n                    o++;\n                }\n            }\n        }\n\n        console.log(i)\n        console.log(o)\n        console.log(vertices.length);\n    }\n\n    render() {\n        return (\n            <React.Fragment>\n                <Toolbar \n                    gridSizeSliderProps={{\n                        label: 'Grid Size',\n                        sliderLength: this.gridSizeValues.length,\n                        sliderValue: this.state.gridSize, \n                        onSliderChange: this.onGridSizeChange\n                    }}\n                    animationSpeedSliderProps={{\n                        label: 'Animation Speed',\n                        sliderLength: this.animationSpeeds.length,\n                        sliderValue: this.state.animationSpeed, \n                        onSliderChange: this.onAnimationSpeedChange\n                    }}\n                    startButtonProps={{\n                        options: Object.keys(this.algorithms),\n                        onStart: this.onStart,\n                        onSelection: this.onSelection\n                    }}\n                    graphProps={{\n                        onSelectDirectedEdges: this.onDirected,\n                        onSelectShowWeights: this.onShowWeights,\n                        onSelectShowVertexPositions: this.onShowPositions,\n                        onGenerateGrid: this.onGenerateGrid,\n                        onGenerateRandom: this.onGenerateRandom,\n                        onClear: this.onClear,\n                    }}\n                />\n                <Grid \n                    gridSize={this.gridSizeValues[this.state.gridSize]} \n                    nodeRadius={5 - this.state.gridSize}\n                    graph={this.state.graph}\n                    isAnimating={this.state.isAnimating}\n                    animationFrame={this.state.animationFrame}\n                />\n            </React.Fragment>\n        );\n    }\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();"],"sourceRoot":""}