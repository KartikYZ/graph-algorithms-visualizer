{"version":3,"sources":["components/slider.tsx","components/button.tsx","components/titledToolbarContainer.tsx","components/checkBox.tsx","components/dropdown.tsx","components/toolbar.tsx","utils/colors.tsx","components/canvas.tsx","graph/vertex.ts","graph/edge.ts","utils/mathFunctions.ts","components/grid.tsx","utils/hashMap.ts","utils/hashSet.ts","graph/graph.ts","utils/queue.ts","graph/algorithms.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Slider","props","state","sliderValue","event","this","onSliderChange","parseInt","currentTarget","value","setState","prevState","type","max","sliderLength","onChange","handleOnChange","name","label","React","Component","Button","handleClick","bind","onClick","className","style","backgroundColor","display","justifyContent","padding","TitledToolbarContainer","border","borderRadius","margin","color","textAlign","paddingBottom","title","children","CheckBox","checkBoxRef","createRef","checkBox","current","checked","onSelect","marginBottom","ref","DropDown","options","map","option","htmlFor","id","defaultValue","Toolbar","handleOnStart","graphProps","onSelectDirectedEdges","onSelectShowWeights","onSelectShowVertexPositions","gridSizeSliderProps","onClear","startButtonProps","onSelection","onGenerateGrid","onGenerateRandom","animationSpeedSliderProps","onStart","rgba","colors","background","gridLines","hoverVertex","hoverEdge","currentVertex","graphVertex","graphEdge","vertexPosition","edgeWeight","edgeWeightBackground","edgeWeightBorder","animRed","animBlue","animGreen","animYellow","animOrange","Canvas","canvasRef","canvas","constCanvasElement","onContextMenu","handleRightClick","onMouseMove","ctx","getContext","width","WIDTH","height","HEIGHT","scale","window","devicePixelRatio","Math","floor","drawGrid","hoveringVertex","hoveringEdge","graph","animationFrame","isDirected","getIsDirected","showPositions","getShowPositions","vertices","edges","t1","performance","now","colorFrame","edge","drawDirectedEdge","drawUndirectedEdge","drawHoverVertex","drawVertexPosition","vertex","equals","drawGraphVertex","old","getColor","setColor","drawCurrentVertex","getShowWeights","drawEdgeWeight","unColorFrame","t2","console","log","round","gridSize","nodeRadius","clearRect","fillStyle","strokeStyle","i","j","xpos","ypos","beginPath","moveTo","lineTo","stroke","arc","PI","fill","x","y","r","lineWidth","save","restore","v","pos","getPosition","drawCircle","VERTEX_RADIUS","drawVertex","box","translate","strokeRect","fillRect","strPos","font","fillText","measureText","e","start","end","drawEdgeArrow","v1","v2","angle","atan2","cos","sin","rotate","clip","weight","getWeight","toString","getEdge","getEnd","getStart","frame","outlineVertices","redVertices","yellowVertices","greenVertices","redEdges","yellowEdges","greenEdges","colorEdges","colorVertices","defaultProps","Vertex","position","data","hash","Edge","p1","p2","parseFloat","sqrt","toFixed","hashCode","getRandomInt","min","ceil","random","getRandomBoolean","Grid","gridState","cursor","nearestVertexInPixels","isAnimating","edgeSet","contains","removeEdge","insertEdge","newVertex","vertexSet","insertVertex","preventDefault","removeVertex","prevNearestVertexInPixels","nativeEvent","offsetX","offsetY","PixelsToVertex","inVertexRadius","handleMouseMove","point","vertexPoint","val","nearest","nearestPixelNode","nearestVertex","HashMap","table","size","length","Array","INITIAL_CAPACITY","key","Error","MAX_LOAD_FACTOR","resizeBackingTable","index","hashAndCompression","getKey","getNext","MapEntry","oldValue","getValue","setValue","toRemove","setNext","keys","entry","push","values","oldTable","counter","head","abs","next","obj","HashSet","put","PRESENT","remove","containsKey","keySet","getSize","getSet","Graph","showWeights","adjacencyMap","u","get","outgoing","incoming","add","IncidenceMap","insertEdgeHelper","a","b","setStart","setEnd","incidenceMap","reverseEdge","Queue","arr","element","first","shift","isEmpty","breadthFirstSearch","startVertex","animation","AnimationBuilder","visited","discovery","queue","enqueue","dequeue","addFrame","outgoingEdges","opposite","recursiveDepthFirstSearch","dfsHelper","visitedVertices","discoveryEdges","frames","cloneFrame","slice","cloneArray","App","gridSizeValues","animationSpeeds","algorithms","onDirected","onShowWeights","onShowPositions","onGridSizeChange","onAnimationSpeedChange","onTest","animationSpeed","algorithm","Object","directedEdges","setIsDirected","setShowWeights","setShowPositions","clear","hdivs","vdivs","xstep","ystep","s","d","right","down","intervalDelay","getFrames","setTimeout","getAdjacencyMap","o","iMap","includes","Fragment","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.02d40d46.chunk.js","sourcesContent":["import React from 'react';\n\ninterface Props {\n    label: string,\n    sliderLength: number\n    sliderValue: number,\n    onSliderChange: (sliderValue: number) => void;\n}\n\ninterface State {\n    sliderValue: number\n}\n\nclass Slider extends React.Component<Props, State> {\n\n    constructor(props: Props) {\n        super(props);\n        this.state = {\n            sliderValue: this.props.sliderValue\n        }\n    }\n\n    handleOnChange(event: React.ChangeEvent<HTMLInputElement>) {\n        this.props.onSliderChange(parseInt(event.currentTarget.value));\n    }\n\n    componentDidUpdate() {\n        this.setState((prevState, props) => {\n            if (props.sliderValue !== prevState.sliderValue) {\n                return {\n                    sliderValue: props.sliderValue\n                }\n            }\n        });\n    }\n\n    render() {\n\n        return (\n            <>\n                <input \n                    type=\"range\" \n                    value={this.state.sliderValue} \n                    max={this.props.sliderLength - 1} \n                    onChange={(event) => this.handleOnChange(event)} \n                    name=\"slider\"\n                />\n                <label>{this.props.label}</label>\n            </>\n        );\n\n    }\n}\n\nexport default Slider;","import React from \"react\";\nimport './styles.css'\n\ninterface Props {\n    label: string,\n    onClick: () => void\n}\n\ninterface State {\n\n}\n\nclass Button extends React.Component<Props, State> {\n\n    constructor(props: Props) {\n        super(props);\n\n        this.handleClick = this.handleClick.bind(this);\n    }   \n\n    handleClick() {     // not necessary?\n        this.props.onClick();\n    }\n\n    render() {\n        let styles = {\n            backgroundColor: '#222222',     // use only one\n            display: 'flex',\n            justifyContent: 'center',\n            padding: '4px',\n        }\n        return (\n            <div className=\"button\" style={styles} onClick={() => this.props.onClick()}>\n                <p className=\"button\" style={{padding: '2px 5px', backgroundColor: '#222222'}}> {this.props.label} </p>\n            </div>\n        );\n    }\n}\n\nexport default Button;","import React from \"react\";\n\ninterface Props {\n    title: string\n}\n\ninterface State {\n\n}\n\nclass TitledToolbarContainer extends React.Component<Props, State> {\n\n    render() {\n        let styles = {\n            backgroundColor: '#333333',\n            border: '1px solid black',\n            borderRadius: '8px',\n            padding: '10px',\n            margin: '0 2px',\n            color: 'rgba(255, 255, 255, 0.8)'\n        }\n        return (\n            <div style={styles}>\n                <h3 style={{textAlign: 'center', paddingBottom: 5}}>{this.props.title}</h3>\n                {this.props.children}\n            </div>\n        );\n    }\n}\n\nexport default TitledToolbarContainer;","import React from \"react\";\n\ninterface Props {\n    label: string\n    onSelect: (selected: boolean) => void\n}\n\nclass CheckBox extends React.Component<Props> {\n    private checkBoxRef: React.RefObject<HTMLInputElement>;\n    constructor(props: Props) {\n        super(props);\n\n        this.checkBoxRef = React.createRef();\n        this.handleClick = this.handleClick.bind(this);\n    }\n\n    handleClick() {\n        if (this.checkBoxRef) {\n            let checkBox = this.checkBoxRef.current;\n            if (checkBox?.checked) {\n                this.props.onSelect(true);\n            } else {\n                this.props.onSelect(false);\n            }\n            \n        }\n    }\n\n    render() {\n        let styles = {\n            padding: '2px',\n            marginBottom: '2px'\n        }\n        return (\n            <div style={styles}>\n                <input type='checkbox' onClick={this.handleClick} ref={this.checkBoxRef}></input>\n                <label> {this.props.label}</label>\n            </div>\n        );\n    }\n}\n\nexport default CheckBox;","import React from 'react';\n\ninterface Props {\n    label: string,\n    options: string[];\n    onChange: (option: string) => void\n}\n\ninterface State {\n\n}\n\nclass DropDown extends React.Component<Props, State> {\n    \n    render() {\n        const options = this.props.options.map((option) => <option key={option} value={option}>{option}</option>);\n        return (\n            <div>\n                <label htmlFor=\"dropdown\">{this.props.label} </label>\n                <select \n                    id=\"dropdown\" \n                    defaultValue={this.props.options[0]}\n                    onChange={(event) => this.props.onChange(event.currentTarget.value)}\n                >\n                    {options}\n                </select>\n            </div>\n        );\n    }\n}\n\nexport default DropDown;","import React from 'react';\n\nimport Slider from './slider';\nimport Button from './button';\nimport './styles.css';\n\nimport TitledToolbarContainer from './titledToolbarContainer';\nimport CheckBox from './checkBox'\nimport DropDown from './dropdown';\n\ninterface Props {\n    gridSizeSliderProps: {\n        label: string,\n        sliderLength: number,\n        sliderValue: number,\n        onSliderChange: (sliderValue: number) => void\n    },\n    animationSpeedSliderProps: {    // make interface\n        label: string,\n        sliderLength: number,\n        sliderValue: number,\n        onSliderChange: (sliderValue: number) => void\n    }\n    startButtonProps: {\n        options: string[],\n        onStart: () => void,\n        onSelection: (option: string) => void,\n    }\n    graphProps: {\n        onSelectDirectedEdges: (selected: boolean) => void,\n        onSelectShowWeights: (selected: boolean) => void,\n        onSelectShowVertexPositions: (selected: boolean) => void,\n        onGenerateGrid: () => void,\n        onGenerateRandom: () => void,\n        onClear: () => void,\n    }\n}\n\ninterface State {\n    \n}\n\nclass Toolbar extends React.Component<Props, State> {\n\n    constructor(props: Props) {\n        super(props);\n\n        this.handleOnStart = this.handleOnStart.bind(this);\n    }\n\n    handleOnStart() {\n\n    }\n    \n    render() {\n        let styles = {\n            backgroundColor: '#222222',\n            // backgroundColor: '#5995da',\n            padding: '10px 0',\n            display: 'flex',\n            justifyContent: 'center',\n        }\n        return (\n            <div style={styles}>\n                <TitledToolbarContainer title=\"Graph\">\n                    <CheckBox label='Directed Edges' onSelect={this.props.graphProps.onSelectDirectedEdges}/>\n                    <CheckBox label='Show Weights' onSelect={this.props.graphProps.onSelectShowWeights}/>\n                    <CheckBox label='Show Vertex Positions' onSelect={this.props.graphProps.onSelectShowVertexPositions}/>\n                    <Slider {...this.props.gridSizeSliderProps} /> \n                    <Button label=\"Clear\" onClick={this.props.graphProps.onClear} />\n                </TitledToolbarContainer>\n                <TitledToolbarContainer title=\"Algorithms\">\n                    <DropDown \n                        label=\"Select Algorithm\" \n                        options={this.props.startButtonProps.options} \n                        onChange={(event) => this.props.startButtonProps.onSelection(event)}\n                    />\n                    <Button label=\"Generate Grid Graph\" onClick={this.props.graphProps.onGenerateGrid} />\n                    <Button label=\"Generate Random Graph\" onClick={this.props.graphProps.onGenerateRandom} />\n                </TitledToolbarContainer>\n                <TitledToolbarContainer title=\"Animation\">\n                    <Slider {...this.props.animationSpeedSliderProps} /> \n                    <Button label=\"Start\" onClick={this.props.startButtonProps.onStart}/>\n                </TitledToolbarContainer>\n                <TitledToolbarContainer title=\"Custom graphs\">\n                    <div>\n                        <p className=\"subtitle\">Addition</p>\n                            1. Click on nodes to start drawing. Click on the currently active source node to exit draw mode. <br />\n                            2. Click on nodes other than the currently active source node to draw edges. <br />\n                            3. Use the toolbar to switch between directed/undirected/weighted/unweighted edges. <br />\n                        <p className=\"subtitle\">Removal</p>\n                            1. Right click on vertex to remove it (and its incident edges, if any). <br />\n                            2. To remove an undirected edge, draw over/retrace the edge. <br />\n                            3. To remove a directed edge, draw/retrace the edge from its tail to the arrowhead. <br />\n                    </div>\n                </TitledToolbarContainer>\n            </div>\n        );\n    }\n}\n\nexport default Toolbar;","export const rgba = {\n    black: 'rgba(0, 0, 0, 1)',\n    partialBlack: 'rgba(0, 0, 0, 0.8)',\n    transBlack: 'rgba(0, 0, 0, 1)',\n    white: 'rgba(255, 255, 255, 1)',\n    partialWhite: 'rgba(255, 255, 255, 0.8)',\n    partialWhite2: 'rgba(255, 255, 255, 0.8)',\n    red: 'rgba(252, 77, 61, 1.0)',\n    blue1: 'rgba(50, 100, 168, 1)',\n    blue2: 'rgba(50, 100, 168, 0.6)',\n    blue3: 'rgba(50, 100, 168, 0.8)',\n    green1: 'rgba(98, 217, 131, 1)',\n    green2: 'rgba(98, 217, 131, 0.5)',\n    yellow: 'rgba(255, 255, 0, 0.9)',\n    orange: 'rgba(255, 165, 0, 1)',\n    purple: 'rgba()',\n    grey: 'rgba(190, 190, 190, 1)',\n    tsprt_grey: 'rgba(190, 190, 190, 0.8)'\n}\n\nexport const colors = {\n    background: rgba.white,\n    gridLines: rgba.grey,\n    hoverVertex: rgba.tsprt_grey,\n    hoverEdge: rgba.tsprt_grey,\n    currentVertex: rgba.partialWhite,\n    graphVertex: rgba.partialWhite,\n    graphEdge: rgba.partialWhite,\n    vertexPosition: rgba.yellow,\n    edgeWeight: rgba.black,\n    edgeWeightBackground: rgba.partialWhite,\n    edgeWeightBorder: rgba.black,\n    animRed: rgba.red,\n    animBlue: rgba.blue1,\n    animGreen: rgba.green1,\n    animYellow: rgba.yellow,\n    animOrange: rgba.orange\n}\n\n// const grid_shade = 190;\n// const hover_shade = 190;\n\n// const COLORS = {\n//     grid_color: `rgba(${grid_shade}, ${grid_shade}, ${grid_shade})`,\n//     node_hover_color: `rgba(${hover_shade}, ${hover_shade}, ${hover_shade}, 0.5)`,\n//     // active_node_color: 'rgba(50, 100, 168, 0.7)',\n//     active_node_color: 'rgba(255, 255, 255, 0.3)',\n//     // current_node_color: 'rgba(98, 217, 131, 0.5)',\n//     current_node_color: 'rgba(255, 255, 255, 0.7)',\n//     inactive_node_color: `rgba(${hover_shade}, ${hover_shade}, ${hover_shade}, 0.7)`,\n//     edge_hover_color: 'rgba(50, 100, 168, 0.5)',\n//     hover_edge_color:'rgba(255, 255, 255, 0.3)',\n//     directed_edge_color: 'rgba(255, 255, 255, 0.7)',\n//     undirected_edge_color: 'rgba(255, 255, 255, 0.6)',\n//     default_edge_color: 'rgba(50, 100, 168, 1)',\n// }\n\n// from drawFrame\n\n// const colors = {\n//     outV: 'rgba(57, 99, 237, 0.8)',\n//     redV: 'rgba(252, 77, 61, 1.0)',\n//     redE: 'rgba(252, 77, 61, 1.0)',\n//     yellowV: 'rgba(255, 255, 0, 0.9)',\n//     yellowE: 'rgba(255, 255, 0, 0.9)',\n//     greenV: 'rgba(57, 237, 171, 0.8)',\n//     greenE: 'rgba(57, 237, 171, 0.8)',\n// }","import React from 'react';\nimport './styles.css';\n\nimport Graph from '../graph/graph';\nimport Vertex from '../graph/vertex';\nimport Edge from '../graph/edge';\nimport { GraphAnimationFrame } from '../graph/algorithms';\nimport { colors } from '../utils/colors';\n\ninterface Props {\n    gridSize: number,\n    nodeRadius: number,\n    hoveringVertex: Vertex<any> | null,\n    hoveringEdge: Edge<any> | null,\n    currentVertex: Vertex<any> | null,\n    graph: Graph<any>,\n    animationFrame: GraphAnimationFrame | null;\n\n    onClick: (event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => void,\n    handleRightClick: (event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => void,\n    onMouseMove: (event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => void\n}\n\nclass Canvas extends React.Component<Props> {\n\n    public static defaultProps = {\n        nodeRadius: 5\n    }\n\n    private canvasRef: React.RefObject<HTMLCanvasElement>;\n    private canvas: HTMLCanvasElement | null;\n    private constCanvasElement: any;\n    \n    public static readonly VERTEX_RADIUS: number = 10;\n    // public static _WIDTH: number = 1280;\n    // public static _HEIGHT: number = 640;\n    public static readonly WIDTH: number = 1600;\n    public static readonly HEIGHT: number = 800;\n\n    constructor(props: Props) {\n        super(props);\n\n        this.canvasRef = React.createRef<HTMLCanvasElement>();\n        this.canvas = null;\n\n        // Dan Abramov on SO: a constant element tells React to never rerender.\n        this.constCanvasElement = <canvas\n            id=\"canvas\" \n            ref={this.canvasRef} \n            onClick={this.props.onClick}\n            onContextMenu={this.props.handleRightClick}\n            onMouseMove={this.props.onMouseMove}\n        />      \n    }\n\n    // lifecycle methods\n    componentDidMount() {\n\n        this.canvas = this.canvasRef.current;\n        \n        if (this.canvas) {\n            \n            let ctx = this.canvas.getContext('2d');\n\n            if (ctx) {\n                this.canvas.style.width = `${Canvas.WIDTH}px`;\n                this.canvas.style.height = `${Canvas.HEIGHT}px`;\n\n                let scale = window.devicePixelRatio;    \n\n                this.canvas.width = Math.floor(Canvas.WIDTH * scale);\n                this.canvas.height = Math.floor(Canvas.HEIGHT * scale);\n\n                ctx.scale(scale, scale);\n\n                this.drawGrid(ctx);\n\n            }   \n        }\n    }\n\n    componentDidUpdate() {\n            \n        let ctx = this.canvas!.getContext('2d');\n\n        if (ctx) {\n\n            this.drawGrid(ctx);\n\n            const {\n                // gridSize, \n                hoveringVertex, \n                hoveringEdge, \n                currentVertex, \n                graph,\n                animationFrame } = this.props;\n\n            let isDirected = graph.getIsDirected();\n            let showPositions = graph.getShowPositions();\n            let vertices = graph.vertices();\n            let edges = graph.edges();\n\n            let t1 = performance.now();\n\n            if (animationFrame) {\n                this.colorFrame(animationFrame);\n\n                // let { outlineVertices } = animationFrame;\n                // if (outlineVertices) {\n                //     for (let vertex of outlineVertices) {\n                //         let v = vertex.getPosition();\n                //         this.drawCircle(\n                //             v[0] * gridSize, \n                //             v[1] * gridSize,\n                //             Canvas.VERTEX_RADIUS + 2, \n                //             colors.animBlue,\n                //             false,\n                //             ctx,\n                //             3\n                //         );\n                //     }\n                // }\n            }\n\n            // edge set\n            if (isDirected) {\n                for (let edge of edges) {\n                    this.drawDirectedEdge(edge, ctx);\n                }\n            } else {\n                for (let edge of edges) {\n                    this.drawUndirectedEdge(edge, ctx);\n                }\n            }     \n\n            // let t2 = performance.now();\n            // console.log(Math.round(t2 - t1));\n            \n            // hover edge\n            if (hoveringEdge) {\n                if (isDirected) {\n                    this.drawDirectedEdge(hoveringEdge, ctx);\n                } else {\n                    this.drawUndirectedEdge(hoveringEdge, ctx);\n                }\n            }\n\n            // hover vertex\n            if (hoveringVertex) {\n                this.drawHoverVertex(hoveringVertex, ctx);\n                if (showPositions) {\n                    this.drawVertexPosition(hoveringVertex, ctx);\n                }\n            }\n\n            // vertex set\n            for (let vertex of vertices) {\n                if (!vertex.equals(currentVertex)) {\n                    this.drawGraphVertex(vertex, ctx);\n                    // if (this.props.graph.getShowPositions()) {\n                    //     this.drawVertexPosition(vertex);\n                    // }\n                }\n            }\n\n            // current active vertex\n            if (currentVertex) {\n                let old = currentVertex.getColor();\n                currentVertex.setColor(colors.currentVertex);\n                this.drawCurrentVertex(currentVertex, ctx);\n                currentVertex.setColor(old);\n                // if (this.props.graph.getShowPositions()) {\n                //     this.drawVertexPosition(currentVertex);\n                // }\n                // how about an outline?\n            }\n        \n            // weights \n            if (this.props.graph.getShowWeights()) {\n                for (let edge of edges) {\n                    this.drawEdgeWeight(edge, false, ctx);\n                }\n            }\n\n            if (animationFrame) {\n                this.unColorFrame(animationFrame);\n            }\n\n            let t2 = performance.now();\n            console.log(Math.round(t2 - t1));\n        }\n    }\n\n    render() {\n        return (\n            // todo: fix height to accommodate for different displays\n            <div className=\"canvas-container\" style={{height: Canvas.HEIGHT + 50, backgroundColor: \"#444444\"}}>\n                {this.constCanvasElement}\n            </div>\n        );\n    }\n\n    // drawing handlers\n    drawGrid(ctx: CanvasRenderingContext2D): void {\n\n        const { gridSize, nodeRadius } = this.props;\n\n        if (ctx) {\n            ctx.clearRect(0, 0, Canvas.WIDTH, Canvas.HEIGHT);\n            \n            ctx.fillStyle = colors.gridLines;\n            ctx.strokeStyle = colors.gridLines;\n            \n            for (let i = 1; i < Canvas.WIDTH / gridSize; i++) {   \n                for (let j = 1; j < Canvas.HEIGHT / gridSize; j++) {\n                    \n                    let xpos = i * gridSize;\n                    let ypos = j * gridSize;\n                    \n                    ctx.beginPath();\n                    ctx.moveTo(0, ypos);\n                    ctx.lineTo(Canvas.WIDTH, ypos);\n                    ctx.stroke();\n            \n                    ctx.beginPath();\n                    ctx.moveTo(xpos, 0);\n                    ctx.lineTo(xpos, Canvas.HEIGHT);\n                    ctx.stroke();\n        \n                    ctx.beginPath();\n                    ctx.arc(i * gridSize, j * gridSize, nodeRadius, 0, 2 * Math.PI);\n                    ctx.fill();\n                    \n                }\n            }\n        }\n        \n    }\n\n    drawCircle(x: number, y: number, r: number, color: string, fill = true, ctx: CanvasRenderingContext2D, lineWidth?: number): void {\n        \n        ctx.save();\n        ctx.beginPath();\n        ctx.arc(x, y, r, 0, 2 * Math.PI, true);\n        \n        if (fill) {\n            ctx.fillStyle = color;\n            ctx.fill();\n        } else {\n            if (lineWidth) {\n                ctx.lineWidth = lineWidth;\n            }\n            ctx.strokeStyle = color;\n            ctx.stroke();\n        }\n\n        ctx.restore();\n    }\n\n    drawVertex(v: Vertex<any>, ctx: CanvasRenderingContext2D): void {\n        \n        const pos: [number, number] = v.getPosition();\n        const { gridSize } = this.props;\n        \n        this.drawCircle(\n            pos[0] * gridSize,\n            pos[1] * gridSize,\n            Canvas.VERTEX_RADIUS,\n            v.getColor(),\n            true,\n            ctx\n        );\n    }\n\n    drawHoverVertex(v: Vertex<any>, ctx: CanvasRenderingContext2D) {\n        this.drawVertex(v, ctx);\n    }\n\n    drawCurrentVertex(v: Vertex<any>, ctx: CanvasRenderingContext2D) {\n        this.drawVertex(v, ctx);\n    }\n\n    drawGraphVertex(v: Vertex<any>, ctx: CanvasRenderingContext2D) {\n        this.drawVertex(v, ctx);\n    }\n\n    drawVertexPosition(v: Vertex<any>, ctx: CanvasRenderingContext2D, box: boolean = false) {\n        let pos = v.getPosition();\n        let { gridSize } = this.props;\n        let x = pos[0] * gridSize;\n        let y = pos[1] * gridSize;\n\n        ctx.save();\n\n        ctx.translate(x, y);\n\n        if (box) {\n            ctx.strokeStyle = 'black';\n            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';\n            ctx.strokeRect(-50, -26, 40, 24);\n            ctx.fillRect(-50, -26, 42, 24);\n        }\n\n        // text   (todo: extract draw text method)\n        let strPos = `(${pos[0]}, ${pos[1]})`;\n        ctx.font = '18px serif';\n        ctx.fillStyle = colors.vertexPosition;\n        ctx.fillText(strPos, -(ctx.measureText(strPos).width + 10), -10);\n        ctx.restore();\n\n        ctx.restore();\n    }\n\n    drawUndirectedEdge(e: Edge<any>, ctx: CanvasRenderingContext2D): void {\n\n        let start = e.start.getPosition();\n        let end = e.end.getPosition();\n        const { gridSize, nodeRadius } = this.props;\n\n        ctx.save();\n        ctx.strokeStyle = e.getColor();\n        ctx.lineWidth = nodeRadius;\n        ctx.beginPath();\n        ctx.moveTo(start[0] * gridSize, start[1] * gridSize);\n        ctx.lineTo(end[0] * gridSize, end[1] * gridSize);\n        ctx.stroke();\n        ctx.restore();\n    }\n\n    drawDirectedEdge(e: Edge<any>, ctx: CanvasRenderingContext2D): void {\n        this.drawUndirectedEdge(e, ctx);\n        this.drawEdgeArrow(e, ctx);\n    }\n\n    drawEdgeArrow(e: Edge<any>, ctx: CanvasRenderingContext2D) {    // consider: make sprite sheet of all possible rotations to reduce draw cost.\n        let v1 = e.start.getPosition();\n        let v2 = e.end.getPosition();\n\n        let { gridSize } = this.props;\n        let angle = Math.atan2(v2[1] - v1[1], v2[0] - v1[0]);\n        let mag = 10;\n        \n        ctx.save();\n\n        ctx.strokeStyle = ctx.fillStyle = e.getColor();\n\n        ctx.translate(\n            v2[0] * gridSize - this.props.nodeRadius * Math.cos(angle),\n            v2[1] * gridSize - this.props.nodeRadius * Math.sin(angle)\n        );\n\n        ctx.rotate(angle);\n        \n        ctx.moveTo(-1.4 * mag, 0);\n        ctx.lineTo(-2 * mag, 0.8 * mag);\n        ctx.lineTo(0, 0);\n        ctx.lineTo(-2 * mag, -0.8 * mag);\n        ctx.lineTo(-1.4 * mag, 0);\n        ctx.stroke();\n        ctx.clip();\n        ctx.fill();\n\n        ctx.restore();\n    }\n\n    drawEdgeWeight(e: Edge<any>, round: boolean, ctx: CanvasRenderingContext2D) {\n\n        let v1 = e.start.getPosition();\n        let v2 = e.end.getPosition();\n        let weight: string = e.getWeight().toString();\n        ctx.save();\n    \n        ctx.translate(\n            0.5 * (v2[0] + v1[0]) * this.props.gridSize,\n            0.5 * (v2[1] + v1[1]) * this.props.gridSize\n        );\n        \n        // container\n        if (round) {\n            this.drawCircle(0, 0, 15, colors.edgeWeightBackground, true, ctx);\n            this.drawCircle(0, 0, 15, colors.edgeWeightBorder, false, ctx);\n        } else {\n            ctx.strokeStyle = colors.edgeWeightBorder;\n            ctx.fillStyle = colors.edgeWeightBackground;\n            ctx.strokeRect(-15, -15, 30, 30);\n            ctx.fillRect(-15, -15, 30, 30);\n        }\n\n        // weight\n        ctx.font = '18px serif';\n        ctx.fillStyle = colors.edgeWeight;\n        ctx.fillText(weight, -ctx.measureText(weight).width / 2, 6);\n        ctx.restore();\n    }\n\n    colorEdges(edges: Edge<any>[], color: string) {\n        for (let edge of edges) {\n            edge.setColor(color);\n        }\n\n        if (!this.props.graph.getIsDirected()) {\n            for (let edge of edges) {\n                let reverseEdge = this.props.graph.getEdge(edge.getEnd(), edge.getStart());\n                reverseEdge!.setColor(color);\n            }\n        }\n    }\n    \n    colorVertices(vertices: Vertex<any>[], color: string) {\n        for (let vertex of vertices) {\n            vertex.setColor(color);\n        }\n    }\n    \n    colorFrame(frame: GraphAnimationFrame) {\n        const { \n            outlineVertices,\n            redVertices, \n            yellowVertices, \n            greenVertices, \n            redEdges, \n            yellowEdges, \n            greenEdges } = frame;\n\n        // const { graph } = this.props;\n\n        if (redEdges) {\n            this.colorEdges(redEdges, colors.animRed);\n        }\n\n        if (yellowEdges) {\n            this.colorEdges(yellowEdges, colors.animYellow);\n        }\n\n        if (greenEdges) {\n            this.colorEdges(greenEdges, colors.animGreen);\n        }\n\n        if (redVertices) {\n            this.colorVertices(redVertices, colors.animRed);\n        }\n\n        if (yellowVertices) {\n            this.colorVertices(yellowVertices, colors.animYellow);\n        }\n\n        if (greenVertices) {\n            this.colorVertices(greenVertices, colors.animGreen);\n        }\n\n        if (outlineVertices) {\n            this.colorVertices(outlineVertices, colors.animOrange);\n        }\n    }\n    \n    unColorFrame(frame: GraphAnimationFrame) {\n        const { \n            outlineVertices,\n            redVertices, \n            yellowVertices, \n            greenVertices, \n            redEdges, \n            yellowEdges, \n            greenEdges } = frame;\n\n        // const { graph } = this.props;\n\n        if (redEdges) {\n            this.colorEdges(redEdges, colors.graphEdge);\n        }\n\n        if (yellowEdges) {\n            this.colorEdges(yellowEdges, colors.graphEdge);\n        }\n\n        if (greenEdges) {\n            this.colorEdges(greenEdges, colors.graphEdge);\n        }\n\n        if (redVertices) {\n            this.colorVertices(redVertices, colors.graphVertex);\n        }\n\n        if (yellowVertices) {\n            this.colorVertices(yellowVertices, colors.graphVertex);\n        }\n\n        if (greenVertices) {\n            this.colorVertices(greenVertices, colors.graphVertex);\n        }\n\n        if (outlineVertices) {\n            this.colorVertices(outlineVertices, colors.graphVertex);\n        }\n    }\n}\n\nexport default Canvas;\n\n// Notes:\n/* \nUsing offsetX and offsetY breaks when zooming in with trackpad. (Standard browser zooming works)\nDisable toolbar UI during animations\n*/","export default class Vertex<T> {\n\n    private position: [number, number];\n    private data: T | undefined;\n    private color: string; \n\n    constructor(position: [number, number], color: string, data?: T) {\n        this.position = position;\n        this.data = data;\n        this.color = color;\n    }\n\n    equals(v: Object | null): boolean {\n        if (!(v instanceof Vertex) || v == null) {\n            return false;\n        } else if (this.position[0] === v.position[0] && this.position[1] === v.position[1]) {\n            return true;\n        }\n        return false;\n    }\n\n    getPosition(): [number, number] {\n        return this.position;\n    }\n\n    getData(): T | undefined {\n        return this.data;\n    }\n\n    getColor(): string {\n        return this.color;\n    }\n\n    setColor(color: string): void {\n        this.color = color;\n    }\n    \n    toString(): string {\n        return `x: ${this.position[0]}, y:${this.position[1]}`;\n    }\n\n    hashCode(): number {\n        let hash = 19;\n        hash = 29 * hash + this.position[0];\n        return 31 * hash + this.position[1];\n    }\n}   ","import Vertex from './vertex';\n\nexport default class Edge<T> {\n\n    public start: Vertex<T>;\n    public end: Vertex<T>;\n    private weight: number;\n    private color: string;\n\n    constructor(start: Vertex<T>, end: Vertex<T>, color: string, weight?: number) {\n        this.start = start;\n        this.end = end;\n        this.color = color;\n        \n        if (weight) {\n            this.weight = weight;\n        } else {\n            let p1 = this.start.getPosition();\n            let p2 = this.end.getPosition();\n            // todo: replace with Euclidean Distance method in Grid Component. Extract as utility method.\n            this.weight = parseFloat((Math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)).toFixed(1));  \n        }\n    }\n\n    equals(e: Object): boolean {\n        if (!(e instanceof Edge) || e == null) {\n            return false;\n        } else if (this.start.equals(e.start) && this.end.equals(e.end)) {\n            return true;\n        }\n        return false;\n    }\n\n    getStart(): Vertex<T> {\n        return this.start;\n    }\n\n    setStart(start: Vertex<T>): void {\n        this.start = start;\n    }\n\n    getEnd(): Vertex<T> {\n        return this.end;\n    }\n\n    setEnd(end: Vertex<T>): void {\n        this.end = end;\n    }\n\n    getWeight(): number {\n        return this.weight;\n    }\n\n    getColor(): string {\n        return this.color;\n    }\n\n    setColor(color: string): void {\n        this.color = color;\n    }\n\n    toString(): string {\n        return `start: ${this.start}, end:${this.end}`;\n    }\n\n    hashCode(): number {\n        let hash = 19;\n        hash = 29 * hash + this.start.hashCode();\n        return 31 * hash + this.end.hashCode();\n    }\n}","\nexport function euclideanDist(p1: number[], p2: number[]) {\n    return Math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2);\n}\n\n/**\n * MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/\n * Global_Objects/Math/random#getting_a_random_integer_between_two_values_inclusive\n * @param min \n * @param max \n * @returns \n */\nexport function getRandomInt(min: number, max: number): number {\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\nexport function getRandomBoolean(): boolean {\n    return getRandomInt(0, 1) === 1;\n}\n\n\n/**\n * RNG with skew.\n * https://stackoverflow.com/a/49434653\n * @param min\n * @param max \n * @param skew \n * @returns \n */\nexport function randn_bm(min: number, max: number, skew: number): number {\n    let u = 0, v = 0;\n    while(u === 0) u = Math.random() //Converting [0,1) to (0,1)\n    while(v === 0) v = Math.random()\n    let num = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v )\n    \n    num = num / 10.0 + 0.5 // Translate to 0 -> 1\n    if (num > 1 || num < 0) \n      num = randn_bm(min, max, skew) // resample between 0 and 1 if out of range\n    \n    else{\n      num = Math.pow(num, skew) // Skew\n      num *= max - min // Stretch to fill range\n      num += min // offset to min\n    }\n    return num\n  }\n\nexport function getSkewedRandomBoolean() {\n    let skews = [0.10, 0.20, 0.80, 1.4, 3, 5, 7, 10, 11];\n    return Math.floor(randn_bm(-1, 2, skews[getRandomInt(0, skews.length - 1)]));\n}\n\nexport function getRandomBool() {\n    return Math.floor(Math.pow(1 - getRandomInt(0, 1), 10)) === 1;\n}\n","import React from 'react';\nimport Canvas from './canvas';\n\nimport Vertex from '../graph/vertex';\nimport Edge from '../graph/edge';\nimport Graph from '../graph/graph'\nimport { GraphAnimationFrame } from '../graph/algorithms';\nimport { colors } from '../utils/colors';\nimport { euclideanDist } from '../utils/mathFunctions'\n\ninterface Props {\n    gridSize: number,\n    nodeRadius: number,\n    graph: Graph<any>,\n    isAnimating: boolean,\n    animationFrame: GraphAnimationFrame | null;\n}\n\ninterface State {\n    hoveringVertex: Vertex<any> | null,\n    currentVertex: Vertex<any> | null,\n    hoveringEdge: Edge<any> | null,\n    graph: Graph<any>\n}\n\ninterface GridState {\n    cursor: [number, number],\n    nearestVertexInPixels: [number, number],\n}\n\nclass Grid extends React.Component<Props, State> {\n\n    private gridState: GridState;\n\n    constructor(props: Props) {\n        super(props);\n\n        let graph = this.props.graph\n\n        this.state = {\n            hoveringVertex: null,\n            currentVertex: null,\n            hoveringEdge: null,\n            graph: graph,\n        }\n\n        this.gridState = {\n            cursor: [-1, -1],\n            nearestVertexInPixels: [-1, -1],\n        }\n    }\n\n    handleClick(event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) {\n\n        if (this.props.isAnimating) {\n            return;\n        }\n\n        let {\n            hoveringVertex,\n            hoveringEdge,\n            currentVertex,\n            graph,\n        } = this.state;\n\n        if (hoveringVertex) {\n            if (hoveringVertex.equals(currentVertex)) {\n                this.setState({\n                    currentVertex: null,\n                    hoveringEdge: null\n                });\n            } else {\n                if (hoveringEdge) {\n                    if (!graph.edgeSet.contains(hoveringEdge)) {\n                        graph.insertEdge(hoveringEdge);\n                    } else {\n                        graph.removeEdge(hoveringEdge);\n                    }\n                }\n\n                let newVertex = new Vertex(hoveringVertex.getPosition(), colors.currentVertex);\n                this.setState({\n                    currentVertex: newVertex,\n                    hoveringEdge: null\n                });\n            }\n\n            if (!graph.vertexSet.contains(hoveringVertex)) {\n                graph.insertVertex(hoveringVertex);\n            }\n        }\n    }\n\n    handleRightClick(event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) {\n        \n        event.preventDefault();\n\n        if (this.props.isAnimating) {\n            return;\n        }\n\n        let {\n            hoveringVertex,\n            graph\n        } = this.state;\n\n        if (hoveringVertex) {\n            if (graph.vertexSet.contains(hoveringVertex)) {\n                graph.removeVertex(hoveringVertex);\n                this.setState({\n                    currentVertex: null,\n                    hoveringEdge: null\n                });\n            }\n        }\n    }\n\n    handleMouseMove(event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) {\n\n        if (this.props.isAnimating) {\n            return;\n        }\n\n        let prevNearestVertexInPixels = this.gridState.nearestVertexInPixels;\n        this.gridState.cursor = [event.nativeEvent.offsetX, event.nativeEvent.offsetY];\n\n        if (this.nearestVertexInPixels(this.gridState.cursor)[0] !== prevNearestVertexInPixels[0] || \n            this.nearestVertexInPixels(this.gridState.cursor)[1] !== prevNearestVertexInPixels[1]) {\n                this.gridState.nearestVertexInPixels = this.nearestVertexInPixels(this.gridState.cursor);\n\n                if (this.state.currentVertex) {\n                    let hoveringEdge = new Edge(this.state.currentVertex, this.PixelsToVertex(this.gridState.nearestVertexInPixels, colors.hoverVertex), colors.hoverEdge);\n                    this.setState({\n                        hoveringEdge: hoveringEdge\n                    });\n                }\n            }\n        \n        if (this.inVertexRadius(this.gridState.cursor)) {\n    \n            if (!this.state.hoveringVertex) {\n                this.setState({\n                    hoveringVertex: this.PixelsToVertex(this.gridState.nearestVertexInPixels, colors.hoverVertex)\n                });\n            }\n\n        } else {\n            \n            if (this.state.hoveringVertex) {\n                this.setState({\n                    hoveringVertex: null\n                });\n            }\n        }\n\n    }\n\n    render() {\n        return (<Canvas \n          gridSize={this.props.gridSize}\n          nodeRadius={this.props.nodeRadius}\n          hoveringVertex={this.state.hoveringVertex}\n          hoveringEdge={this.state.hoveringEdge}\n          currentVertex={this.state.currentVertex}\n          graph={this.state.graph}\n          animationFrame={this.props.animationFrame}\n\n          onClick={(event) => this.handleClick(event)}\n          handleRightClick={(event) => this.handleRightClick(event)}\n          onMouseMove={(event) => this.handleMouseMove(event)}\n        />);\n    }\n\n    // utility methods\n\n    PixelsToVertex(point: [number, number], color: string): Vertex<any> {\n        let vertexPoint = point.map((val) => val / this.props.gridSize);\n        return new Vertex([vertexPoint[0], vertexPoint[1]], color);\n    }\n\n    /**\n     * \n     * @param cursor size 2 array where cursor[0] = cursorX, cursor[1] = cursorY; pixel position on canvas element.\n     * @returns pixel position of nearest vertex relative to cursor position on grid as size 2 array.\n     */\n     nearestVertexInPixels(cursor: [number, number]): [number, number] {\n        \n        const { gridSize } = this.props;\n        let nearest: number[] = cursor.map((val) => Math.round(val / gridSize) * gridSize)\n        let nearestPixelNode: [number, number] = [nearest[0], nearest[1]];\n        \n        switch (nearestPixelNode[0]) {\n            case 0:\n                nearestPixelNode[0] += gridSize;\n                break;\n            case Canvas.WIDTH:\n                nearestPixelNode[0] -= gridSize;\n                break;\n            default:\n                break;\n        }\n\n        switch (nearestPixelNode[1]) {\n            case 0:\n                nearestPixelNode[1] += gridSize;\n                break;\n            case Canvas.HEIGHT:\n                nearestPixelNode[1] -= gridSize;\n                break;\n            default:\n                break;\n        }\n\n        return nearestPixelNode;\n    }\n\n    inVertexRadius(cursor: [number, number]): boolean {\n        let nearestVertex: [number, number] = this.nearestVertexInPixels(cursor);\n        if (nearestVertex[0] > 0 && nearestVertex[0] < Canvas.WIDTH && nearestVertex[1] > 0 && nearestVertex[1] < Canvas.HEIGHT) {\n            return euclideanDist(cursor, nearestVertex) < Canvas.VERTEX_RADIUS;\n        }\n        return false;\n    }\n\n}\n\nexport default Grid;","import { Hashable } from \"./hashable\";\n\n// TODO: See deductions and rectify!\n\nexport default class HashMap<K extends Hashable, V> {\n\n    private table: (MapEntry<K, V> | null)[];\n    private size: number;\n    private length: number;\n\n    public static readonly INITIAL_CAPACITY = 13;\n    public static readonly MAX_LOAD_FACTOR = 0.75;\n\n    constructor() {\n        this.table = new Array<MapEntry<K, V> | null>(HashMap.INITIAL_CAPACITY);\n        this.length = HashMap.INITIAL_CAPACITY;\n        this.size = 0;\n    }\n\n    public put(key: K, value: V): V | null {\n        // exceptions\n        if (key == null) {\n            throw new Error(\"Key is null.\");\n        } else if (value == null) {\n            throw new Error(\"Value is null.\");\n        }\n\n        // load factor check\n        if ((this.size + 1) / (this.length) > HashMap.MAX_LOAD_FACTOR) {\n            this.resizeBackingTable(2 * this.length + 1);\n        }\n\n        // index corresponding to key in the table\n        let index: number = this.hashAndCompression(key);\n        let current: MapEntry<K, V> | null = this.table[index];\n\n        // duplicate check\n        while (current != null && !current.getKey().equals(key)) {\n            current = current.getNext();\n        }\n\n        // current == null <-> unique entry\n        if (current == null) {\n            this.table[index] = new MapEntry<K, V>(key, value, this.table[index]);\n            this.size++;\n            return null;\n        }\n        // current != null <-> duplicate entry\n        let oldValue: V = current.getValue();\n        // current.setKey(key);    // replace key reference;\n        current.setValue(value);\n        return oldValue;\n    }\n\n    public remove(key: K): V {\n        if (key == null) {\n            throw new Error(\"Given key is null.\");\n        }\n        let index = this.hashAndCompression(key);\n        let current: MapEntry<K, V> | null = this.table[index];\n\n        if (current == null) {\n            throw new Error(`Key: ${key} not in map.`);\n        }\n\n        let toRemove: V | null = null;\n        \n        if (current.getKey().equals(key)) {\n            toRemove = current.getValue();\n            this.table[index] = current.getNext();\n            this.size--;\n            return toRemove;\n        }\n\n        while (current != null && current.getNext() != null) {\n            if (current.getNext()!.getKey().equals(key)) {\n                toRemove = current.getNext()!.getValue();\n                current.setNext(current.getNext()!.getNext());\n                this.size--;\n                break;\n            }\n            current = current.getNext();\n        }\n\n        if (toRemove == null) {\n            throw new Error(`Key: ${key} not in map.`);\n        }\n\n        return toRemove;\n    }\n\n    public get(key: K): V {\n        if (key == null) {\n            throw new Error(\"Key is null.\");\n        }\n        let index = this.hashAndCompression(key);\n        let current = this.table[index];\n\n        while (current != null) {\n            if (current.getKey().equals(key)) {\n                return current.getValue();\n            }\n            current = current.getNext();\n        }\n        throw new Error(\"Key: \" + key + \" not in map.\");\n    }\n\n    public getKey(key: K): K | null {  // get reference contained within map.\n        if (key == null) {\n            throw new Error(\"Key is null.\");\n        }\n        let index = this.hashAndCompression(key);\n        let current = this.table[index];\n\n        while (current != null) {\n            if (current.getKey().equals(key)) {\n                return current.getKey();\n            }\n            current = current.getNext();\n        }\n        // throw new Error(\"Key: \" + key + \" not in map.\");\n        return null;\n    }\n\n    public containsKey(key: K): boolean {\n        if (key == null) {\n            throw new Error(\"Key is null.\");\n        }\n        let index = this.hashAndCompression(key);\n        let current = this.table[index];\n        while (current != null) {\n            if (current.getKey().equals(key)) {\n                return true;\n            }\n            current = current.getNext();\n        }\n        return false;\n    }\n\n    public keySet(): K[] {\n    // public keySet(): HashSet<K> {\n        \n        // let keys = new HashSet<K>();\n        let keys: K[] = [];\n        for (let entry of this.table) {\n            if (entry) {\n                let current: MapEntry<K, V> | null = entry;\n                while (current != null) {\n                    keys.push(current.getKey());\n                    current = current.getNext();\n                }\n            }\n\n            // break on keys.size() == size\n            // if (keys.getSize() === this.size) {\n            if (keys.length === this.size) {\n                break;      // prevents traversal of additional null values in table base array.\n            }\n        }\n\n        return keys;\n    }\n\n    public values(): V[] {\n        let values = [];\n        for (let entry of this.table) {\n            if (entry) {\n                let current: MapEntry<K, V> | null = entry;\n                while (current != null) {\n                    values.push(current.getValue());\n                    current = current.getNext();\n                }\n            }\n            if (values.length === this.size) {\n                break;      // prevents traversal of additional null values in table base array.\n            }\n        }\n\n        return values;\n    }\n\n    public getSize() {\n        return this.size;\n    }\n\n    public clear(): void {\n        this.table = new Array<MapEntry<K, V> | null>(HashMap.INITIAL_CAPACITY);\n        this.length = HashMap.INITIAL_CAPACITY;\n        this.size = 0;\n    }\n\n    private resizeBackingTable(length: number): void {\n        \n        if (length < this.size) {\n            throw new Error(`Length: ${length} is less than current size of hash map.`);\n        }\n\n        // if length == table.length, new table will remain unchanged after 'resize'.\n        if (length === this.length) {\n            return;\n        }\n\n        // initialize new array.\n        let oldTable: (MapEntry<K, V> | null)[] = this.table;\n        this.table = new Array<MapEntry<K, V>>(length);\n        this.length = length;\n        let counter = 0;\n\n        // hash and compress elements iteratively and add to new array.\n        for (let head of oldTable) {\n            if (head) {\n                let current: MapEntry<K, V> | null = head;\n                \n                while (current) {\n                    let key: K = current.getKey();\n                    let value: V = current.getValue();\n                    let index = this.hashAndCompression(key);\n                    this.table[index] = new MapEntry<K, V>(key, value, this.table[index]);\n                    counter++;\n                    current = current.getNext();\n                }\n            }\n\n            if (counter === this.size) {\n                return;\n            }\n        }\n    }\n\n    private hashAndCompression(key: K): number {\n        return Math.abs(key.hashCode() % this.length);\n    }\n}\n\n\nclass MapEntry<K extends Hashable, V> {\n\n    private key: K;\n    private value: V;\n    private next: MapEntry<K, V> | null;\n\n    /**\n     * Constructs a new MapEntry with the given key, value, and next reference.\n     *\n     * @param key   the key in the new entry\n     * @param value the value in the new entry\n     * @param next  the next entry in the external chain\n     */\n    constructor(key: K, value: V, next: MapEntry<K, V> | null) {\n        this.key = key;\n        this.value = value;\n        if (next) {\n            this.next = next;\n        } else {\n            this.next = null;\n        }\n    }\n\n    public getKey(): K {\n        return this.key;\n    }\n\n    public getValue(): V {\n        return this.value;\n    }\n\n    public getNext(): MapEntry<K, V> | null {\n        return this.next;\n    }\n\n    public setKey(key: K): void {\n        this.key = key;\n    }\n\n    public setValue(value: V): void {\n        this.value = value;\n    }\n\n    public setNext(next: MapEntry<K, V> | null): void {\n        this.next = next;\n    }\n\n    public toString(): string {\n        let key: string = this.key.toString();\n        let value: V = this.value;\n        return `(${key}, ${value})`;\n    }\n\n    public equals(obj: object): boolean {\n        if (!(obj instanceof MapEntry)) {\n            return false;\n        } else {\n            // let other: MapEntry<K, V> = obj as MapEntry<K, V>;\n            return obj.getKey().equals(this.key) && obj.getValue().equals(this.value);\n        }\n    }\n}","import { Hashable } from './hashable'\nimport HashMap from './hashMap';\n\n/**\n * HashSet based on the Java Implementation of the same\n */\nexport default class HashSet<E extends Hashable> {\n    private static readonly PRESENT: Object = {};\n    private map: HashMap<E, Object>;\n    \n    constructor() {\n        this.map = new HashMap();\n    }\n\n    public add(data: E): void {\n        this.map.put(data, HashSet.PRESENT);\n    }\n\n    public remove(data: E) {\n      return this.map.remove(data);\n    }\n\n    public get(data: E): E | null {    // get reference contained within set.\n        return this.map.getKey(data);\n    }\n\n    public contains(data: E): boolean {\n        return this.map.containsKey(data);\n    }\n\n    public getSet(): E[] {\n        return this.map.keySet();\n    }\n\n    getSize(): number {\n        return this.map.getSize();\n    }\n\n    clear(): void {\n        this.map = new HashMap();\n    }\n\n    toString(): string {\n        return this.getSet().toString();\n    }\n}","import Vertex from \"./vertex\";\nimport Edge from \"./edge\";\nimport HashSet from \"../utils/hashSet\";\nimport HashMap from \"../utils/hashMap\";\nimport { Equatable } from \"../utils/hashable\";\nimport { colors } from \"../utils/colors\";\n\n/**\n * Adjacency Map (modified) Implementation of Goodrich, Tamassia, Goldwasser's Graph ADT. (Data Structures and Algorithms in Java)\n */ \nexport default class Graph<T> {\n    \n    private isDirected: boolean;\n    private showWeights: boolean;   // canvas rendering \n    private showPositions: boolean; // canvas rendering \n    public vertexSet: HashSet<Vertex<T>>;   // make private. Use this.references in canvas.\n    public edgeSet: HashSet<Edge<T>>;\n    private adjacencyMap: HashMap<Vertex<T>, IncidenceMapInterface<T>>;     // ?use linked positional list for vertices \n\n    constructor(isDirected: boolean, showWeights: boolean, showPositions: boolean) {\n        this.isDirected = isDirected;\n        this.showWeights = showWeights;\n        this.showPositions = showPositions;\n\n        this.vertexSet = new HashSet();\n        this.edgeSet = new HashSet();\n        this.adjacencyMap = new HashMap();\n    }\n\n    numVertices(): number  {\n        return this.vertexSet.getSize();\n    }\n\n    numEdges(): number {\n        return this.edgeSet.getSize();\n    }\n\n    vertices(): Vertex<T>[] {\n        return this.vertexSet.getSet();\n    }\n\n    edges(): Edge<T>[] {\n        return this.edgeSet.getSet();\n    }\n\n    getEdge(u: Vertex<T>, v: Vertex<T>): Edge<T> | null {\n        try {\n            return this.adjacencyMap.get(u).outgoing.get(v);\n        } catch {\n            return null;\n        }\n    }\n\n    endVertices(e: Edge<T>): Vertex<T>[] {\n        return [e.getStart(), e.getEnd()];\n    }\n\n    opposite(v: Vertex<T>, e: Edge<T>) {\n        if (v.equals(e.getStart())) {\n            return e.getEnd();\n        } else if (v.equals(e.getEnd())) {\n            return e.getStart();\n        } else {\n            throw new Error(`${e} not incident to ${v}`);\n        }\n    }\n\n    outDegree(v: Vertex<T>): number {\n        return this.adjacencyMap.get(v).outgoing.getSize();\n    }\n\n    inDegree(v: Vertex<T>): number {\n        return this.adjacencyMap.get(v).incoming.getSize();\n    }\n\n    outgoingEdges(v: Vertex<T>): Edge<T>[] {\n        return this.adjacencyMap.get(v).outgoing.values();\n    }\n\n    incomingEdges(v: Vertex<T>): Edge<T>[] {\n        return this.adjacencyMap.get(v).incoming.values();\n    }\n\n    insertVertex(v: Vertex<T>): void {\n        if (this.vertexSet.contains(v)) {\n            return;\n        }\n        \n        v.setColor(colors.graphVertex);\n        this.vertexSet.add(v);\n        this.adjacencyMap.put(v, new IncidenceMap<T>());\n    }\n\n    insertEdge(e: Edge<T>): void {\n        this.insertEdgeHelper(e);\n\n        if (!this.isDirected) {\n            this.insertEdgeHelper(new Edge(e.getEnd(), e.getStart(), e.getColor()));\n        }\n    }\n\n    private insertEdgeHelper(e: Edge<T>): void {\n        if (this.edgeSet.contains(e)) {\n            return;\n        }\n\n        let a = e.getStart();\n        let b = e.getEnd();\n\n        if (this.vertexSet.contains(a)) {\n            e.setStart(this.vertexSet.get(a)!);\n        } else {\n            a.setColor(colors.graphVertex);\n            this.insertVertex(a);\n        }\n\n        if (this.vertexSet.contains(b)) {\n            e.setEnd(this.vertexSet.get(b)!);\n        } else {\n            b.setColor(colors.graphVertex);\n            this.insertVertex(b);\n        }\n\n        let u = e.getStart();\n        let v = e.getEnd();\n\n        e.setColor(colors.graphEdge);\n        this.edgeSet.add(e);\n\n        this.adjacencyMap.get(u).outgoing.put(v, e);\n        this.adjacencyMap.get(v).incoming.put(u, e);\n    }\n\n    /**\n     * Removes Vertex v and all its incident edges in (deg(v)) time.\n     * @param v \n     */\n    removeVertex(v: Vertex<T>): void {  // return removed Vertex?\n        this.vertexSet.remove(v);\n\n        let incidenceMap = this.adjacencyMap.get(v);\n        \n        for (let edge of incidenceMap.incoming.values()) {\n            this.removeEdge(edge);\n        }\n        \n        for (let edge of incidenceMap.outgoing.values()) {\n            this.removeEdge(edge);\n        }\n\n        this.adjacencyMap.remove(v);\n\n    }\n\n    /**\n     * Removes edge e from the graph in O(1) time.\n     * @param e \n     */\n    removeEdge(e: Edge<T>): void {\n        this.edgeSet.remove(e);\n\n        let u = e.getStart();\n        let v = e.getEnd();\n\n        // remove from u.outgoing\n        this.adjacencyMap.get(u).outgoing.remove(v);\n        // remove from v.incoming\n        this.adjacencyMap.get(v).incoming.remove(u);\n\n        if (!this.isDirected) {     // commenting block out fixed the issue of removing reverse edges. Inspect this.\n            // remove from u.incoming\n            this.adjacencyMap.get(u).incoming.remove(v);\n            // remove from v.outgoing\n            this.adjacencyMap.get(v).outgoing.remove(u);\n            // remove from edgeSet\n            let reverseEdge = new Edge(e.getEnd(), e.getStart(), e.getColor());\n            this.edgeSet.remove(reverseEdge);\n        }\n    }\n\n    clear(): void {\n        this.vertexSet = new HashSet();\n        this.edgeSet = new HashSet();\n        this.adjacencyMap = new HashMap();\n    }\n\n    getAdjacencyMap(): HashMap<Vertex<T>, IncidenceMap<T>> {     // for debugging.\n        return this.adjacencyMap;\n    }\n\n    getIsDirected(): boolean {\n        return this.isDirected;\n    }\n\n    setIsDirected(isDirected: boolean): void {\n        \n        if (this.isDirected && !isDirected) {\n            // add reverse edges.\n            for (let edge of this.edgeSet.getSet()) {\n                let reverseEdge = new Edge(edge.getEnd(), edge.getStart(), edge.getColor());\n                this.insertEdge(reverseEdge);\n            }\n        }\n\n        this.isDirected = isDirected;\n    }\n\n    getShowWeights(): boolean {\n        return this.showWeights;\n    }\n\n    setShowWeights(showWeights: boolean): void {\n        this.showWeights = showWeights;\n    }\n\n    getShowPositions(): boolean {\n        return this.showPositions;\n    }\n\n    setShowPositions(showPositions: boolean): void {\n        this.showPositions = showPositions;\n    }\n}\n\ninterface IncidenceMapInterface<T> {\n    incoming: HashMap<Vertex<T>, Edge<T>>,\n    outgoing: HashMap<Vertex<T>, Edge<T>>, \n    equals: (obj: object) => boolean\n}\n\nclass IncidenceMap<T> implements IncidenceMapInterface<T>, Equatable {\n    public incoming: HashMap<Vertex<T>, Edge<T>>\n    public outgoing: HashMap<Vertex<T>, Edge<T>>\n    \n    constructor() {\n        this.incoming = new HashMap();\n        this.outgoing = new HashMap();\n    }\n\n    equals(obj: Object): boolean {\n        if (!(obj instanceof IncidenceMap) || obj == null) {\n            return false;\n        }\n        return this.incoming === obj.incoming && this.outgoing === obj.outgoing;    // reference equality.\n    }\n} \n\n","export default class Queue<T> {\n    private arr: T[];\n    \n    constructor() {\n        this.arr = [];\n    }\n\n    enqueue(element: T): void {\t\n        this.arr.push(element);\n    }\n\n    dequeue(): T {    \n        let first = this.arr.shift();\n        if (first) {\n            return first;\n        } else {\n            throw new Error(\"Underflow.\");\n        }\n    }\n\n    peekFirst(): T | null {\n        if(this.isEmpty()) {\n            return null;\n        }\n        return this.arr[0];\n    }\n\n    isEmpty(): boolean {\n        return this.arr.length === 0;\n    }\n\n}","import HashSet from \"../utils/hashSet\";\n// import Stack from \"../utils/stack\";\nimport Queue from \"../utils/queue\";\nimport Graph from \"./graph\";\nimport Vertex from \"./vertex\";\nimport Edge from \"./edge\";\nimport HashMap from \"../utils/hashMap\";\n\nexport function breadthFirstSearch(graph: Graph<any>, startVertex: Vertex<any>): AnimationBuilder {\n\n    let animation = new AnimationBuilder();\n    let visited = new HashSet<Vertex<any>>();\n    let discovery: Edge<any>[] = [];\n    let queue = new Queue<Vertex<any>>();\n    \n    queue.enqueue(startVertex);\n    \n    while (!queue.isEmpty()) {\n        let currentVertex = queue.dequeue();\n        if (!visited.contains(currentVertex)) {\n            \n            animation.addFrame({ outlineVertices: [currentVertex], redVertices: visited.getSet(), redEdges: discovery });\n            visited.add(currentVertex);\n            \n            animation.addFrame({ outlineVertices: [currentVertex], redVertices: visited.getSet(), redEdges: discovery });\n            animation.addFrame({ \n                outlineVertices: [currentVertex], \n                redVertices: visited.getSet(), \n                redEdges: discovery,\n                yellowEdges: graph.outgoingEdges(currentVertex), \n            });\n\n            for (let edge of graph.outgoingEdges(currentVertex)) {\n                let opposite = graph.opposite(currentVertex, edge);\n                discovery.push(...graph.outgoingEdges(currentVertex));\n                queue.enqueue(opposite);\n            }\n        }\n    }\n    animation.addFrame({ redVertices: visited.getSet(), redEdges: discovery });\n\n    return animation;\n}\n\nexport function recursiveDepthFirstSearch(graph: Graph<any>, startVertex: Vertex<any>): AnimationBuilder {\n    let animation = new AnimationBuilder();\n    let visited = new HashSet<Vertex<any>>();\n    let discovery = new HashMap<Vertex<any>, Edge<any>>();\n    dfsHelper(graph, startVertex, visited, discovery, animation);\n    return animation;\n}\n\nfunction dfsHelper(graph: Graph<any>, u: Vertex<any>, \n    visitedVertices: HashSet<Vertex<any>>, discoveryEdges: HashMap<Vertex<any>, Edge<any>>, animation: AnimationBuilder) {\n    \n    visitedVertices.add(u);\n    animation.addFrame({ \n        outlineVertices: [u], \n        redVertices: visitedVertices.getSet(), \n        redEdges: discoveryEdges.values(),\n    })\n\n    for (let edge of graph.outgoingEdges(u)) {\n        let v: Vertex<any> = graph.opposite(u, edge);\n        if (!visitedVertices.contains(v)) {\n            discoveryEdges.put(v, edge);\n            animation.addFrame({ \n                outlineVertices: [u], \n                redVertices: visitedVertices.getSet(), \n                redEdges: discoveryEdges.values(), \n                yellowEdges: graph.outgoingEdges(u) \n            });\n\n            dfsHelper(graph, v, visitedVertices, discoveryEdges, animation);\n            animation.addFrame({ \n                outlineVertices: [u], \n                redVertices: visitedVertices.getSet(), \n                redEdges: discoveryEdges.values(), \n            })\n\n        }\n    }\n}\n\nexport class AnimationBuilder {\n    private frames: GraphAnimationFrame[];\n\n    constructor() {\n        this.frames = [];\n    }\n\n    public addFrame(frame: GraphAnimationFrame) {\n        this.frames.push(this.cloneFrame(frame));\n    }\n\n    public getFrames(): GraphAnimationFrame[] {\n        return this.frames;\n    }\n\n    private cloneArray(arr: any[] | null | undefined): any[] | null {\n        return arr ? arr.slice(0, arr.length): null;\n    }\n\n    private cloneFrame(frame: GraphAnimationFrame): GraphAnimationFrame {\n        // todo: explore ways to 'object map'\n        return {\n            outlineVertices: this.cloneArray(frame.outlineVertices),\n            redVertices: this.cloneArray(frame.redVertices),\n            redEdges: this.cloneArray(frame.redEdges),\n            yellowVertices: this.cloneArray(frame.yellowVertices),\n            yellowEdges: this.cloneArray(frame.yellowEdges),\n            greenVertices: this.cloneArray(frame.greenEdges),\n            greenEdges: this.cloneArray(frame.greenEdges)\n        }\n    }\n}\n\nexport interface GraphAnimationFrame {\n    outlineVertices?: Vertex<any>[] | null,\n    redVertices?: Vertex<any>[] | null,\n    redEdges?: Edge<any>[] | null,\n    yellowVertices?: Vertex<any>[] | null,\n    yellowEdges?: Edge<any>[] | null,\n    greenVertices?: Vertex<any>[] | null,\n    greenEdges?: Edge<any>[] | null\n}\n\n// function dfsHelper(graph: Graph<any>, startVertex: Vertex<any>, \n//     visited: HashSet<Vertex<any>>, discovery: HashSet<Edge<any>>, animation: AnimationBuilder): void {\n\n//     // TODO: record discovery edges.\n\n//     // mark start as visited;\n//     // animation.addFrame(visited.getSet(), startVertex, discovery.getSet());\n//     visited.add(startVertex);\n//     animation.addFrame(visited.getSet(), startVertex, discovery.getSet(), null);\n//     // for each of start's outgoing edges:\n//     for (let edge of graph.outgoingEdges(startVertex)) {\n//         // if (other endpoint is not visited):\n//         let opposite = graph.opposite(startVertex, edge);\n//         if (!visited.contains(opposite)) {\n//             // depthFirstSearch(other endpoint of edge);\n//             discovery.add(edge);\n//             animation.addFrame(visited.getSet(), startVertex, discovery.getSet(), graph.outgoingEdges(startVertex));\n//             // display outgoing edges.\n//             // set explorationEdge(edge)\n//             // animation.addFrame(visited.getSet(), discoveryEdges.getSet(), graph.outgoingEdges(startVertex));\n//             dfsHelper(graph, opposite, visited, discovery, animation);\n//             animation.addFrame(visited.getSet(), startVertex, discovery.getSet(), null);\n//         }\n//     }  \n// }\n\n/*\nOne frame of DFS:\n    actual graph: taken care of by Canvas ComponentDidUpdate\n\n    start vertex: default is first inserted vertex, (todo:) can be changed through toolbar\n    current vertex: the one dfs is called recursively on\n    outgoing edges from current vertex: adjMap\n    visited vertices: maintain a collection\n    discovery edges: maintain a collection\n\n*/\n// export function iterativeDepthFirstSearch(graph: Graph<any>, startVertex: Vertex<any>): AnimationBuilder {\n//     let visited = new HashSet<Vertex<any>>();\n//     let discovery = new HashMap<Vertex<any>, Edge<any>>();\n//     let animation = new AnimationBuilder();\n//     let stack = new Stack<Vertex<any>>();\n\n//     stack.push(startVertex);\n\n//     while (!stack.isEmpty()) {\n//         let u = stack.pop();\n\n//         // animation.addFrame({ outlineVertices: [u], redVertices: visited.getSet(), redEdges: discovery.values() })\n//         visited.add(u);\n//         // animation.addFrame({ outlineVertices: [u], redVertices: visited.getSet(), redEdges: discovery.values() })\n\n//         for (let edge of graph.outgoingEdges(u)) {\n//             let v: Vertex<any> = graph.opposite(u, edge);\n//             if (!visited.contains(v)) {\n//                 discovery.put(v, edge);\n//                 stack.push(v);\n//             }\n//         }\n//     }\n    \n//     return animation;\n// }\n","import React from 'react';\nimport './App.css';\n\nimport Toolbar from './components/toolbar';\nimport Grid from './components/grid';\nimport Graph from './graph/graph';\nimport { recursiveDepthFirstSearch, breadthFirstSearch, AnimationBuilder, GraphAnimationFrame } from './graph/algorithms';\nimport Vertex from './graph/vertex';\nimport Edge from './graph/edge';\nimport { getRandomBoolean, getRandomInt } from './utils/mathFunctions';\nimport { colors } from './utils/colors';\n\ninterface Props {\n\n}\n\ninterface State {\n    gridSize: number,\n    animationSpeed: number\n    graph: Graph<any>,\n    isAnimating: boolean,\n    animationFrame: GraphAnimationFrame | null,\n    algorithm: string\n}\n\ninterface IDAlgorithmMap {\n    [key: string]: (graph: Graph<any>, startVertex: Vertex<any>) => AnimationBuilder\n}\n\nclass App extends React.Component<Props, State> {\n\n    // private gridSizeValues: number[] = [100, 80, 40, 32, 25, 20, 16];\n    // private gridSizeValues: number[] = [100, 80, 40];\n    private gridSizeValues: number[] = [100, 80];\n    private animationSpeeds: number[] = [2000, 1000, 500, 400, 200, 100, 50, 20];\n    private algorithms: IDAlgorithmMap;\n\n    constructor(props: Props) {\n        super(props);\n\n        this.onDirected = this.onDirected.bind(this);\n        this.onShowWeights = this.onShowWeights.bind(this);\n        this.onShowPositions = this.onShowPositions.bind(this);\n        this.onGridSizeChange = this.onGridSizeChange.bind(this);\n        this.onGenerateGrid = this.onGenerateGrid.bind(this);\n        this.onGenerateRandom = this.onGenerateRandom.bind(this);\n        this.onClear = this.onClear.bind(this);\n        this.onSelection = this.onSelection.bind(this);\n        this.onAnimationSpeedChange = this.onAnimationSpeedChange.bind(this);\n        this.onStart = this.onStart.bind(this);\n\n        // testing\n        this.onTest = this.onTest.bind(this);\n\n        this.algorithms = {\n            'dfs': recursiveDepthFirstSearch,\n            'bfs': breadthFirstSearch\n        }\n\n        this.state = {\n            gridSize: 0,\n            animationSpeed: 2,\n            graph: new Graph(false, false, false),\n            isAnimating: false,\n            animationFrame: null,\n            algorithm: Object.keys(this.algorithms)[0]\n        }    \n    }\n\n    componentDidMount() {\n        // this.onTest();\n    }\n\n    onDirected(directedEdges: boolean) {\n        if (this.state.isAnimating) {\n            return;\n        }\n        this.state.graph.setIsDirected(directedEdges);\n        this.setState({});\n    }\n\n    onShowWeights(showWeights: boolean) {\n        this.state.graph.setShowWeights(showWeights);\n        this.setState({});\n    }\n\n    onShowPositions(showPositions: boolean) {\n        this.state.graph.setShowPositions(showPositions);\n        this.setState({});\n    }\n\n    onGridSizeChange(sliderValue: number) {\n        if (this.state.isAnimating) {\n            return;\n        } else if (this.state.gridSize > sliderValue) {\n            this.state.graph.clear();\n        }\n        this.setState({gridSize: sliderValue});\n    }\n\n    onGenerateRandom() {\n        if (this.state.isAnimating) {\n            return;\n        }\n\n        let gridSize = this.gridSizeValues[this.state.gridSize];    // todo: state holds gridSize rather than index\n        let hdivs: number = 1600 / gridSize;\n        let vdivs: number = 800 / gridSize;\n\n        this.state.graph.clear();\n\n        let xstep = [1, 2, 3, 4][getRandomInt(0, 3)];\n        let ystep = [1, 2, 3, 4][getRandomInt(0, 3)];\n\n        for (let y = 1; y < vdivs; y += ystep) {\n            for (let x = 1; x < hdivs; x += xstep) {\n                if (getRandomBoolean() && getRandomBoolean()) {\n                    this.state.graph.insertVertex(new Vertex([x, y], colors.graphVertex));\n                }\n            }\n        }\n\n        for (let u of this.state.graph.vertices()) {\n            for (let v of this.state.graph.vertices()) {\n                if (getRandomBoolean() && getRandomBoolean() && getRandomBoolean() && !u.equals(v)) {\n                    this.state.graph.insertEdge(new Edge(u, v, colors.graphEdge));\n                }\n            }\n        }\n\n        this.setState({});\n\n    }\n\n    onGenerateGrid() {\n        if (this.state.isAnimating) {\n            return;\n        }\n\n        let gridSize = this.gridSizeValues[this.state.gridSize];\n        let hdivs: number = 1600 / gridSize;\n        let vdivs: number = 800 / gridSize;\n\n        this.state.graph.clear();\n\n        for (let y = 1; y < vdivs; y++) {\n            for (let x = 1; x < hdivs; x++) {\n                let s = new Vertex([x, y], colors.graphVertex);\n                let r = new Vertex([x + 1, y], colors.graphVertex);\n                let d = new Vertex([x, y + 1], colors.graphVertex);\n                let right = new Edge(s, r, colors.graphEdge);\n                let down = new Edge(s, d, colors.graphEdge);\n                if (x !== hdivs - 1) {\n                    this.state.graph.insertEdge(right);\n                }\n\n                if (y !== vdivs - 1)  {\n                    this.state.graph.insertEdge(down);\n                }\n            }\n        }\n\n        this.setState({});\n    }\n\n    onClear() {\n        if (this.state.isAnimating) {\n            return;\n        }\n\n        this.state.graph.clear();\n        this.setState({});\n    }\n\n    onSelection(option: string) {\n        this.setState({ algorithm: option })\n    }\n\n    onAnimationSpeedChange(sliderValue: number) {\n        this.setState({ animationSpeed: sliderValue });\n    }\n\n    onStart() {\n        if (this.state.isAnimating) {\n            return;\n        }\n\n        let intervalDelay = this.animationSpeeds[this.state.animationSpeed];\n\n        if (this.state.graph.vertices().length === 0) {\n            return;\n        }\n\n        this.setState({isAnimating: true});\n\n        let frames = this.algorithms[this.state.algorithm](this.state.graph, this.state.graph.vertices()[0]).getFrames();\n\n        for (let i = 0; i < frames.length; i++) {\n            // if (i === frames.length - 1) {\n            //     let lastFrame = frames[i];\n            //     if (lastFrame.redVertices) {\n            //         for (let vertex of lastFrame.redVertices) {\n            //             if (!this.state.graph.vertices().includes(vertex)) {\n            //                 console.log(vertex.toString());\n            //             }\n            //         }\n            //     }\n            // }\n            setTimeout(() => {\n                this.setState({\n                    animationFrame: frames[i]\n                });\n            }, (i + 1) * intervalDelay);\n        }\n\n        // use requestAnimationFrame or recursive setTimout.\n        setTimeout(() => {this.setState({isAnimating: false, animationFrame: null})}, ((frames.length + 1) * intervalDelay) + 3000);\n        // setTimeout(() => {this.setState({isAnimating: false, animationFrame: frames[frames.length - 1]})}, ((frames.length + 1) * intervalDelay) + 3000);\n    }\n\n    onTest() {\n        console.log('testing.');\n        // this.test1();\n        // this.test2();\n        console.log('end of test.')\n    }\n\n    test1() {\n        let vertices = this.state.graph.vertices();\n        let edges = this.state.graph.edges();\n\n        console.log(vertices);\n        console.log(edges);\n\n        for (let vertex of vertices) {\n            vertex.setColor(colors.animBlue);\n        }\n\n        for (let edge of edges) {\n            edge.setColor(colors.animBlue);\n        }\n        this.setState({});\n    }\n\n    test2() {\n        this.onGenerateGrid();\n        let vertices = this.state.graph.vertices();\n        let map = this.state.graph.getAdjacencyMap();\n\n        let i = 0;\n        let o = 0;\n\n        for (let v of vertices) {\n            let iMap = map.get(v);\n            for (let u of iMap.incoming.keySet()) {\n                if (vertices.includes(u)) {\n                    console.log(u.toString());\n                    i++;\n                }\n            }\n\n            for (let u of iMap.outgoing.keySet()) {\n                if (vertices.includes(u)) {\n                    console.log(u.toString());\n                    o++;\n                }\n            }\n        }\n\n        console.log(i)\n        console.log(o)\n        console.log(vertices.length);\n    }\n\n    render() {\n        return (\n            <React.Fragment>\n                <Toolbar \n                    gridSizeSliderProps={{\n                        label: 'Grid Size',\n                        sliderLength: this.gridSizeValues.length,\n                        sliderValue: this.state.gridSize, \n                        onSliderChange: this.onGridSizeChange\n                    }}\n                    animationSpeedSliderProps={{\n                        label: 'Animation Speed',\n                        sliderLength: this.animationSpeeds.length,\n                        sliderValue: this.state.animationSpeed, \n                        onSliderChange: this.onAnimationSpeedChange\n                    }}\n                    startButtonProps={{\n                        options: Object.keys(this.algorithms),\n                        onStart: this.onStart,\n                        onSelection: this.onSelection\n                    }}\n                    graphProps={{\n                        onSelectDirectedEdges: this.onDirected,\n                        onSelectShowWeights: this.onShowWeights,\n                        onSelectShowVertexPositions: this.onShowPositions,\n                        onGenerateGrid: this.onGenerateGrid,\n                        onGenerateRandom: this.onGenerateRandom,\n                        onClear: this.onClear,\n                    }}\n                />\n                <Grid \n                    gridSize={this.gridSizeValues[this.state.gridSize]} \n                    nodeRadius={5 - this.state.gridSize}\n                    graph={this.state.graph}\n                    isAnimating={this.state.isAnimating}\n                    animationFrame={this.state.animationFrame}\n                />\n            </React.Fragment>\n        );\n    }\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();"],"sourceRoot":""}